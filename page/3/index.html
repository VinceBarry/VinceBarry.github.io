<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>RoadToGeek技术小屋（少年，别再收藏文章了！）</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="RoadToGeek技术小屋">
<meta property="og:type" content="website">
<meta property="og:title" content="RoadToGeek技术小屋（少年，别再收藏文章了！）">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="RoadToGeek技术小屋（少年，别再收藏文章了！）">
<meta property="og:description" content="RoadToGeek技术小屋">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="RoadToGeek技术小屋（少年，别再收藏文章了！）">
<meta name="twitter:description" content="RoadToGeek技术小屋">
  
    <link rel="alternate" href="/atom.xml" title="RoadToGeek技术小屋（少年，别再收藏文章了！）" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">RoadToGeek技术小屋（少年，别再收藏文章了！）</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">RoadToGeek技术小屋</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-利用LruCache和Volley解决ListView图片加载错位问题" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/05/12/利用LruCache和Volley解决ListView图片加载错位问题/" class="article-date">
  <time datetime="2016-05-11T16:04:17.000Z" itemprop="datePublished">2016-05-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android第三方开源库/">Android第三方开源库</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/12/利用LruCache和Volley解决ListView图片加载错位问题/">利用LruCache和Volley解决ListView图片加载错位问题</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>写作原因：在使用ListView加载大量图片时常常会出现图片错位的问题，解决方案是通过图片缓存防止重复请求实现，下面的文章或许可以帮助你解决以上问题，另外文章涉及Volley加载图片的使用，本人不才，求大神指教。</strong></p>
<p><a href="https://github.com/lesliebeijing/VolleyListViewImageDemo" target="_blank" rel="external">参考源码</a><br><a href="http://developer.android.com/reference/android/util/LruCache.html" target="_blank" rel="external">Android API</a></p>
<hr>
<h2 id="LruCache类简介"><a href="#LruCache类简介" class="headerlink" title="LruCache类简介"></a>LruCache类简介</h2><p>LruCache类，先找一下Android API，API上面是这样说的：LruCache是一个用于储存限制数量的强引用（强引用是指创建一个对象并把这个对象赋给一个引用变量。强引用有引用变量指向时永远不会被垃圾回收。即使内存不足的时候。<br>一个用于储存强引用的缓存）的Cache。每次当一个Value被访问，该Value所在的强引用会被移动至队列的头。当一个Value被加进一个满的Cache时，队列最后的Value会被撤出并实施垃圾回收。说白了LruCache就是一个指定大小的缓存区。所以要为它指定缓存区大小，下面的Override实现为LruCache指定缓存区大小。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int cacheSize = 4 * 1024 * 1024; // 指定单条缓存大小最多为4MiB</span><br><span class="line">   LruCache bitmapCache = new LruCache(cacheSize) &#123;</span><br><span class="line">       protected int sizeOf(String key, Bitmap value) &#123;</span><br><span class="line">           return value.getByteCount();  </span><br><span class="line">   &#125;&#125;//Override sizeOf()方法，返回bitmap的字节大小</span><br></pre></td></tr></table></figure>
<h2 id="ImageCache的实现"><a href="#ImageCache的实现" class="headerlink" title="ImageCache的实现"></a>ImageCache的实现</h2><p>下面我们通过实现ImageCache来自定义一个BitmapCache类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class BitmapCache implements ImageCache &#123;</span><br><span class="line">    private LruCache&lt;String, Bitmap&gt; mCache;</span><br><span class="line"></span><br><span class="line">    public BitmapCache() &#123;</span><br><span class="line">        int maxSize = 4 * 1024 * 1024;</span><br><span class="line">        mCache = new LruCache&lt;String, Bitmap&gt;(maxSize) &#123;</span><br><span class="line">            @Override</span><br><span class="line">            protected int sizeOf(String key, Bitmap bitmap) &#123;</span><br><span class="line">                return bitmap.getByteCount();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Bitmap getBitmap(String url) &#123;</span><br><span class="line">        Log.i(&quot;leslie&quot;, &quot;get cache &quot; + url);</span><br><span class="line">        return mCache.get(url);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void putBitmap(String url, Bitmap bitmap) &#123;</span><br><span class="line">        Log.i(&quot;leslie&quot;, &quot;add cache &quot; + url);</span><br><span class="line">        if (bitmap != null) &#123;</span><br><span class="line">            mCache.put(url, bitmap);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述代码实现了ImageCache接口（Volley框架），这个接口功能就是实现图片的缓存。我们使用LruCache来实现它，在构造方法中实例化LruCache指定缓存大小，然后Override getBitmap()和putBitmap()方法，分别用于获取图片缓存和写入缓存。BitmapCache类是后面的Volley异步加载图片操作的一个参数。</p>
<h2 id="Volley异步加载图片操作"><a href="#Volley异步加载图片操作" class="headerlink" title="Volley异步加载图片操作"></a>Volley异步加载图片操作</h2><p>接着便是进行Volley异步加载网络图片操作：<br>第一步，启动队列：<br><code>RequestQueue queue = Volley.newRequestQueue(context);</code><br>第二步：创建ImageLoader：<br><code>ImageLoader imageLoader = new ImageLoader(queue, new BitmapCache());</code><br>此步中<br>第三步：实例化NetWorkImageView：<br><code>NetWorkImageView img.setImageUrl(imgUrl, imageLoader);</code><br>通过调用setImageUrl()方法将待显示的图片的URL和创建好的ImageLoader传入。</p>
<h2 id="思路整理"><a href="#思路整理" class="headerlink" title="思路整理"></a>思路整理</h2><p>上述过程整体可以理解为，有一个ImageLoader,它在每次有异步加载图片的请求时，将请求放入队列中，已经缓存好的图片将其放入缓存区（使用LruCache来实现缓存）；然后每次需要显示时，就通过URL查找对应的键值对，在缓存区中找到对应的Bitmap返回给显示控件（NetWorkImageView），从而很好地实现了图片缓存机制。<br>下面就是ListView展示图片的工作了，这里不再多加阐述了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从上面的应用看出，图片缓存机制在需要大量图片展示时是十分必要的，而LruCache和Volley ImageLoader的结合使用很好地实现了图片的缓存，从而能够解决ListView多图显示出现的图片错位等等问题。</p>
<p>本人学艺不精，上述阐述如有问题，请指教。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/05/12/利用LruCache和Volley解决ListView图片加载错位问题/" data-id="cir1zx7dw002lxgyuxe6akpzh" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原创/">原创</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Android二维码扫描开发（三）：zxing库的使用及图像亮度信息提取" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/05/03/Android二维码扫描开发（三）：zxing库的使用及图像亮度信息提取/" class="article-date">
  <time datetime="2016-05-03T05:12:18.000Z" itemprop="datePublished">2016-05-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android第三方开源库/">Android第三方开源库</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/03/Android二维码扫描开发（三）：zxing库的使用及图像亮度信息提取/">Android二维码扫描开发（三）：zxing库的使用及图像亮度信息提取</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>zxing是google提供的一个开源的条码处理的库，可支持maxicode、qrcode、pdf17等多种条码，github地址如下：<br><a href="https://github.com/zxing/zxing" target="_blank" rel="external">zxing Gitub地址</a></p>
<p><img src="http://www.codernote.top/static/blog/file/2016/03/QQ%E6%88%AA%E5%9B%BE20160325144921_20160325165548.png" alt="zxing"></p>
<p>可以看出，内容还是非常多的，我们用到的也是只其中的核心部分，都在core包里面，这里提供一个打包好的zxing.jar给大家来用，或者你可以自己下载了源码自己打包。</p>
<p><a href="http://www.codernote.top/static/blog/file/2016/03/zxing_20160325165738.zip" target="_blank" rel="external">压缩包</a></p>
<p>下面我们来看看zxing库的用法</p>
<p><strong>[二维码生成]</strong></p>
<p>二维码生成主要是使用QRCodeWriter这个类，encode()方法传入需要编码的字符串，会返回一个BitMatrix，然后我们把它转化转化为Bitmap可用的byte[]类型数据，就可以生成Bitmap了。</p>
<p><img src="http://www.codernote.top/static/blog/file/2016/03/blob_20160325174331.png" alt="QRcreate"></p>
<p>BitMatrix的get()方法返回的是boolean类型的数据，true代表二维码深色像素，false代表二维码浅色像素。注意，深色和浅色如果颜色差别不够明显，二维码有可能将无法识别，差别越大，识别成功率越高。所以一般推荐使用黑色和白色来显示二维码。</p>
<p><strong>[二维码识别]</strong></p>
<p>二维码识别可使用QRCodeReader或者MultiFormatReader这两个类，区别是，后者可以识别除了二维码之外的一些条码。本例中使用的是MultiFormatReader。</p>
<p>首先我们需要把图像源数据转换为可识别的亮度信息，zxing提供了LuminanceSource这个抽象类，根据不同的图像类型，其中的getMatrix()方法和getRow()方法需要自己来实现。zxing也提供好了planar类型的YUV图像和RGB图像的LuminanceSource，只需要传入源数据即可。</p>
<p><img src="http://www.codernote.top/static/blog/file/2016/03/blob_20160325171059.png" alt="xinxi"></p>
<p>本例中改写了这两个类，增加了灰度图像Bitmap生成的方法。不管是用zxing提供的，还是自己来改写，了解了原理，写代码就很简单了。YUV图像和RGB图像如何提取亮度信息后面会讲到，这里先把zxing讲完。</p>
<p>LuminanceSource需要封装为HybridBinarizer,再封装为BinaryBitmap，然后通过MultiFormatReader.decodeWithState()方法进行二维码解析，解析失败会抛出异常，解析成功返回一个Result类型的结果，使用Result.getText()方法就可以得到解析后的字符串了。</p>
<p><img src="http://www.codernote.top/static/blog/file/2016/03/blob_20160325174400.png" alt="code"></p>
<p>注意，二维码的解析是耗时操作，为避免ANR，我们要把它放到子线程里，本例中使用的是AsyncTask。</p>
<p><strong>[亮度信息处理]</strong></p>
<p>对于YUV图像，前一篇已经介绍过。相对于RGB图像来说，YUV图像提取亮度信息很简单，只保留Y数据，忽略UV数据即可。相机返回的数据，大都是YUV类型数据。</p>
<p>如果是识别本地图像，我们需要对RGB图像做亮度信息的计算。前一篇也有介绍如何通过RGB数据来计算亮度信息，还记得这个公式么：</p>
<pre><code>Y = 0.299 R + 0.587 G + 0.114 B
</code></pre><p>不过在实际写代码的过程中，浮点运算太过麻烦和耗时，我们可以改变下公式，得到一个近似值就可以了：</p>
<pre><code>Y = (R + 2*G + B)/4  或者 Y = (R + G + G + B) &gt;&gt; 2
</code></pre><p>通过上面的公式就可以得到亮度信息的近似值。</p>
<p>关于Android二维码的应用就介绍到这里，欢迎大家多多关注。</p>
<p><a href="https://github.com/xushanmeng/QRCodeScannerDemo" target="_blank" rel="external">点击查看二维码扫描Demo源码</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/05/03/Android二维码扫描开发（三）：zxing库的使用及图像亮度信息提取/" data-id="cir1zx7ba0007xgyutue21p74" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/转载/">转载</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Android二维码扫描开发（二）：YUV图像格式详解" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/05/03/Android二维码扫描开发（二）：YUV图像格式详解/" class="article-date">
  <time datetime="2016-05-03T05:11:34.000Z" itemprop="datePublished">2016-05-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android第三方开源库/">Android第三方开源库</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/03/Android二维码扫描开发（二）：YUV图像格式详解/">Android二维码扫描开发（二）：YUV图像格式详解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>上一篇中，我们了解了Android二维码扫描开发的实现思路和原理。其中从相机里获取到的数据是NV21格式的，NV21属于YUV图像，当然有些外置摄像头会返回其他YUV格式的数据，那么我们就来看一看，到底什么是YUV图像。</p>
<p>RGB图像大家都了解，RGB图像分为了三个颜色分量，R红色分量，G绿色分量，B蓝色分量。而YUV图像，也是分为了三个分量，Y亮度分量，用来表示明亮度，也叫灰阶值，U分量和V分量是色值分量，用来表示图像色彩与饱和度，其中U分量也叫Cb，表示的图像蓝色偏移量，V分量也叫Cr，用来表示图像红色部分偏移量，所以YUV有时也写作YCbCr。</p>
<p>YUV图像把亮度和色度分开了，避免了亮度和色度的相互干扰，可以在降低色度采样率的情况下，保持图像的视觉质量。</p>
<p><strong>[采样比率]</strong></p>
<p>下面我们来看看YUV图像的采样方式，是如何改变色度采样率的。YUV图像有以下几种采样比例：</p>
<p>444采样中，Y:U:V=4:4:4，每一个Y对应一个UV，水平和垂直方向都保持原数据；</p>
<p>422采样中，Y:U:V=4:2:2，每两个Y共用一个UV，水平方向采用2:1采样，垂直方向保持原数据；</p>
<p>411采样中，Y:U:V=4:1:1，每四个Y共用一个UV，水平方向采用4:1采样，垂直方向保持原数据；</p>
<p>420采样中，Y:UV=4:2或Y:U:V=4:1:1，每四个Y共用一个UV，水平方向和垂直方向都采用2:1采样。</p>
<p>如果用×表示Y数据，用〇表示UV数据，那么下面几种采样如下图所示：<br><img src="http://www.codernote.top/static/blog/file/2016/03/YUV%E9%87%87%E6%A0%B7_20160324141159.png" alt="caiyang"></p>
<p><strong>[存储方式]</strong></p>
<p>YUV数据的存储方式分为打包的(packed)和平面的(planar)。</p>
<p>packed存储方式是，每一组YUV作为一个连续存储，每个组后面跟着另外一组，常见的有UYVY、YUYV等类型，以YUYV(属于YUV422)为例，储存方式如下图所示：<br><img src="http://www.codernote.top/static/blog/file/2016/03/YUYV422_20160324144247.png" alt="cunchu1"></p>
<p>从上图中可以看出，两个相邻的Y共用一组UV，Y和UV是交错储存的。</p>
<p>planar储存方式是，先是连续的Y，然后是连续的UV，UV可以交错也可以不交错。以YUV420为例，YUV420分为YUV420P和YUV420SP,区别是YUV420P中U和V是分开连续存储的，YUV420SP中，UV是交错存储的。如下图所示：</p>
<p><img src="http://www.codernote.top/static/blog/file/2016/03/YUYV420_20160324150343.png" alt="cunchu2"></p>
<p><strong>[常见YUV格式]</strong></p>
<ul>
<li><p>YUYV，YUYV属于YUV422，根据上面的图像也可以看出来，Y和UV是按照(YUYV)(YUYV)(YUYV)…的格式交错存储的。</p>
</li>
<li><p>UYVY，UYVY也是YUV422图像，和YUYV类似，不过是Y和UV的存储顺序按照(UYVY)(UYVY)(UYVY)…的顺序存储的。</p>
</li>
<li><p>YUV422P，属于YUV422图像，其中Y、U、V分别连续存储。</p>
</li>
<li><p>NV21和NV12,这两种格式都属于YUV420SP图像，Y连续存储，然后是交错的UV,二者区别是，NV21是V在U前，NV12是U在V前。</p>
</li>
<li><p>YU12和YV12，这两种格式属于YUV420P图像，Y、U、V分别连续存储。区别是YU12是Y在前，其次是U，最后是V；而YV12是Y在前，其次是V，最后是U。</p>
</li>
<li><p>I420，即YU12图像。</p>
</li>
</ul>
<p><strong>[YUV图像处理]</strong></p>
<ol>
<li><p>YUV422和YUV420之间的转换</p>
<p>YUV422转YUV420，需要在垂直方向上隔行采样，只保留奇数行或偶数行的UV数据。YUV420转YUV422，需要在垂直方向上，将一行拷贝成两行。</p>
</li>
<li><p>YUV转RGB</p>
<p>YUV和RGB的计算方法，用矩阵公式表示的话，如下图所示：</p>
<p><img src="http://www.codernote.top/static/blog/file/2016/03/YUV%E8%BD%ACRGB_20160324162455.png" alt="matrix"></p>
</li>
</ol>
<p>如果用算数公式表示的话如下所示：</p>
<p>RGB转YUV:</p>
<pre><code>Y = 0.299 R + 0.587 G + 0.114 B

U = - 0.1687 R - 0.3313 G + 0.5 B + 128

V = 0.5 R - 0.4187 G - 0.0813 B + 128
</code></pre><p>YUV转RGB</p>
<pre><code>R = Y + 1.402 (V - 128)

G = Y - 0.34414 (U - 128) - 0.71414 (V - 128)

B = Y + 1.772 (U - 128)
</code></pre><p>注意，这里只是单个像素点的转换方法，图像里的批量转换，还需根据YUV的储存格式进行考虑。</p>
<p>YUV图像就先讲解到这里，下一篇我将对YUV图像和RGB图像的亮度计算，以及zxing的使用方法进行介绍。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/05/03/Android二维码扫描开发（二）：YUV图像格式详解/" data-id="cir1zx7c0000lxgyuvrbr0vyl" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/转载/">转载</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Android二维码扫描开发（一）：实现思路与原理" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/05/03/Android二维码扫描开发（一）：实现思路与原理/" class="article-date">
  <time datetime="2016-05-03T04:49:41.000Z" itemprop="datePublished">2016-05-03</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android第三方开源库/">Android第三方开源库</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/05/03/Android二维码扫描开发（一）：实现思路与原理/">Android二维码扫描开发（一）：实现思路与原理</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>写作原因现在二维码的使用已经十分普遍，各种传单广告，各大媒体都能见到它的影子，所以许多应用中都有二维码扫描生成功能，在自己的应用（特别是社交，分享类）加入二维码扫描是很有必要的。Google官方提供的Zxing库就能实现二维码扫描功能，下面我们一起拜读一下猿人记事关于Zxing的用法的解析实现。</strong></p>
<p><a href="http://www.codernote.top/blog/info/117?hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io" target="_blank" rel="external">Android二维码扫描开发（一）：实现思路与原理</a></p>
<hr>
<p>现在二维码已经非常普及了，那么二维码的扫描与处理也成为了Android开发中的一个必要技能。网上有很多关于Android中二维码处理的帖子，大都是在讲开源框架zxing用法，然后贴贴代码就完了，并没有一个系统的分析和原理解析。其中涉及到的Camera的操作和YUV图像处理，也大都没有详细的介绍。所以我自己写了这篇文章，把Android二维码的开发来从头捋一下。</p>
<p>本例界面如下图所示，代码链接在文章最下方：</p>
<p><img src="http://www.codernote.top/static/blog/file/2016/03/Screenshot_20160323-105716_20160323150030.png" alt="ScannerActivity"> <img src="http://www.codernote.top/static/blog/file/2016/03/device-2016-03-23-145909_20160323150037.png" alt="ResultActivity"></p>
<p>二维码处理流程分为几个步骤：</p>
<ol>
<li>初始化相机，设置一些相机参数；</li>
<li>绑定SurfaceView，在SurfaceView上显示预览图像；</li>
<li>获取相机的一帧图像；</li>
<li>对图像进行一定的预处理，只保留亮度信息，成为灰度图像；</li>
<li>对灰度图像进行二维码解析，解析成功进入下一步，不成功回到第③步；</li>
<li>返回解析结果并退出。</li>
</ol>
<p>流程图如下图所示：<br><img src="http://www.codernote.top/static/blog/file/2016/03/%E4%BA%8C%E7%BB%B4%E7%A0%81%E6%89%AB%E6%8F%8F%E5%8E%9F%E7%90%86_20160323134744.png" alt="liucheng"></p>
<p>下面我们来具体看一看每一步都该怎么实现。</p>
<h3 id="一、初始化相机"><a href="#一、初始化相机" class="headerlink" title="一、初始化相机"></a>一、初始化相机</h3><p>相机使用的是android.hardware.Camera这个类，在Android 5.0之后，推荐使用更强大的android.hardware.Camera2这个类，为了兼容更低版本Android系统，我们在这里仍然使用Camera类来实现。Camera可以通过setDisplayOrientation()方法设置预览图像的方向，旋转度数只能是0、90、180、270中的一个,根据需求，本例中设置为90度。Camera还可以通过Camera.Parameters类设置预览图像的分辨率，但是只能在气可支持的分辨率中选择一个，不能随便设置，我们需要根据屏幕大小,在其中选出一个最佳的预览图像分辨率，太大浪费资源，太小会显示不清楚，具体选择方法，在代码中有，这里就不细述了。Camera可以通过setPreviewFormat()方法来设置预览图像的数据格式，推荐选择的有ImageFormat.NV21和ImageFormat.YV12，默认是NV21。NV21属于YUV图像，和RGB图像有所不同，YUV图像在下一篇会有详细介绍。</p>
<p>注意在使用Camera时，需要在AndroidManifest.xml里声明一些权限：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission android:name=&quot;android.permission.CAMERA&quot; /&gt;</span><br><span class="line">&lt;uses-permission android:name=&quot;android.permission.FLASHLIGHT&quot; /&gt;</span><br><span class="line">&lt;uses-feature android:name=&quot;android.hardware.camera&quot; /&gt;</span><br><span class="line">&lt;uses-feature android:name=&quot;android.hardware.camera.autofocus&quot; /&gt;</span><br><span class="line">&lt;uses-feature android:name=&quot;android.hardware.camera.flash&quot; /&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="二、绑定SurfaceView"><a href="#二、绑定SurfaceView" class="headerlink" title="二、绑定SurfaceView"></a>二、绑定SurfaceView</h3><p>在SurfaceView创建好后，通过Camera类的setPreviewDisplay()方法，将SurfaceHolder传入Camera。<br>调用Camera的startPreview()方法，Camera捕捉到的图像就会显示到SurfaceView上了。</p>
<h3 id="三、获取一帧图像"><a href="#三、获取一帧图像" class="headerlink" title="三、获取一帧图像"></a>三、获取一帧图像</h3><p>调用Camera的setOneShotPreviewCallback(PreviewCallback cb)方法，可以请求获取一帧图像，获取到图像后，会调用PreviewCallback的onPreviewFrame(byte[] data, Camera camera)方法,其中的data参数就是图像的YUV数据了。</p>
<h3 id="四、图像预处理"><a href="#四、图像预处理" class="headerlink" title="四、图像预处理"></a>四、图像预处理</h3><p>根据二维码的原理，我们只需要图像的亮度信息来进行二维码解析，所以我们要把获取到的彩色图像转换为灰度图像。YUV图像转换为灰度图像的方法，以及RGB图像转换为灰度图像的方法，在后续文章中会有介绍，这里只说原理，具体实现就不再赘述。</p>
<h3 id="五、二维码解析"><a href="#五、二维码解析" class="headerlink" title="五、二维码解析"></a>五、二维码解析</h3><p>在这里，二维码解析使用的是google的zxing开源框架，把上一步处理后的灰度图像，封装为zxing的LuminanceSource，再封装为zxing的BinaryBitmap,然后就可以进行二维码解析了。<br>值得一提的是，利用zxing解析二维码是耗时操作，为避免ANR,需要写到子线程中来处理。<br>具体代码在这里就不贴了，后续章节中将会对zxing的使用及LuminanceSource的处理做详细解答。</p>
<h3 id="六、解析结果"><a href="#六、解析结果" class="headerlink" title="六、解析结果"></a>六、解析结果</h3><p>本例中，除了返回解析到的字符串之外，还对LuminanceSource增加了一个renderCroppedGreyScaleBitmap()方法，用来生成处理好的灰度图像Bitmap。</p>
<p>二维码扫描的大致流程和原理就叙述到这里了，下一篇将会对YUV图像进行详细的介绍。</p>
<p><a href="https://github.com/xushanmeng/QRCodeScannerDemo" target="_blank" rel="external">查看二维码扫描Demo源码</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/05/03/Android二维码扫描开发（一）：实现思路与原理/" data-id="cir1zx7b70006xgyu5qpyzkoe" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/转载/">转载</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-利用Android回调机制对Dialog进行简单封装" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/30/利用Android回调机制对Dialog进行简单封装/" class="article-date">
  <time datetime="2016-04-30T04:59:55.000Z" itemprop="datePublished">2016-04-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android知识库/">Android知识库</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/30/利用Android回调机制对Dialog进行简单封装/">利用Android回调机制对Dialog进行简单封装</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>写作原因：Android回调机制是Android开发者绕不开的一个点，对于它的掌握学习十分重要。本文由于作者水平有限可能存在纰漏，对于回调机制的学习掌握仍在途中，以后会推出更多的相关文章。</strong></p>
<hr>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>接口回调是Android中一种常用的机制，如Button点击事件就是接口回调的具体实现。Fragment与Activity之间的通信机制也是基于接口回调实现，感兴趣的可以阅读博主上篇关于Fragment通信的文章（基于Google官方文档）：<a href="http://roadtogeek.cn/2016/04/30/Fragment%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1/" target="_blank" rel="external">Fragment间的通信</a>。对于接口回调，作为初学者，个人有一下的一点认识：我们可以把接口看作是一个呼叫端口，是在某个功能类（发送方）完成自身功能过程中触发某些动作时通过接口中的某一个方法呼叫接口，然后接口将这种呼叫传至实现该接口的类（接收处理方）中，该类通过实现回调方法对该呼叫作出反馈。下面是Wikipedia上面关于回调机制的定义，有兴趣可以看看。</p>
<blockquote>
<p>In computer programming, a callback is a piece of executable code that is passed as an argument to other code, which is expected to call back (execute) the argument at some convenient time. The invocation may be immediate as in a synchronous callback, or it might happen at a later time as in an asynchronous callback. In all cases, the intention is to specify a function or subroutine as an entity that is, depending on the language, more or less similar to a variable.</p>
</blockquote>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>实现代码是最好的学习方式，下面博主通过封装一个简单的Dialog来讲解接口回调的具体用法。平常使用Dialog时如果按照标准写法来有时会显得很繁琐，博主因为特定需要将其封装成一个只有message和“确定”，“取消”按钮点击事件的工具。下面我将按照步骤一步步实现：</p>
<h3 id="定义接口"><a href="#定义接口" class="headerlink" title="定义接口"></a>定义接口</h3><p>在简介中已经说过，接口是一个呼叫端口，是通信的中介。内部的方法类比为不同请求。的本例中的接口是在我们点击Positive Button和Negative Button时被呼叫的。所以定义一下的接口：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface onButtonClick&#123;</span><br><span class="line">        public void OnPositive();</span><br><span class="line">        public void OnNegative();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的接口中有两个方法，分别在点击Positive Button和Negative Button时回调</p>
<h3 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h3><p>这包括两个部分，一个是在功能类（发送方）向接口发出呼叫时实现回调：<br>先创建回调对象mCallBack：<br><code>private onButtonClick mButtonClickCallBack;</code><br>然后在触发某个动作时（当点击Dialog上的按钮时）发出回调（呼叫接口）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">builderSec.setPositiveButton(&quot;确定&quot;, new DialogInterface.OnClickListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(DialogInterface dialog, int which) &#123;</span><br><span class="line"></span><br><span class="line">                mButtonClickCallBack.OnPositive();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        builderSec.setNegativeButton(&quot;取消&quot;, new DialogInterface.OnClickListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(DialogInterface dialog, int which) &#123;</span><br><span class="line">                mButtonClickCallBack.OnNegative();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure></p>
<p>在另一个类（接收处理方）中实现回调方法对该呼叫作出反馈：<br>先实现该接口，可以在功能类中定义以下方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void setOnButtonClick(onButtonClick mNegativeCallBack) &#123;</span><br><span class="line">        this.mButtonClickCallBack = mNegativeCallBack;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MyDialog deleteDialog = new MyDialog(getActivity(),&quot;RTGBrowser&quot;,&quot;是否删除当前历史记录？&quot;);</span><br><span class="line">                deleteDialog.setOnButtonClick(new MyDialog.onButtonClick() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void OnPositive() &#123;</span><br><span class="line">                        //TODO:在这里实现点击Positive按钮的逻辑；</span><br><span class="line">                    &#125;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void OnNegative() &#123;</span><br><span class="line">                        //TODO:在这里实现点击Negative按钮的逻辑；</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br></pre></td></tr></table></figure>
<p>这样就通过接口回调实现对一个Dialog进行封装，下面贴出完整的代码：</p>
<h2 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h2><p><strong>MyDialog.class</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">package com.example.vincebarry.exam.function;</span><br><span class="line">import android.content.Context;</span><br><span class="line">import android.content.DialogInterface;</span><br><span class="line">import android.support.v7.app.AlertDialog;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Created by VinceBarry on 2016/5/2.</span><br><span class="line"> * 那现在一起来总结一下基本的回调是如何实现的，首先创建一个接口，这个接口用于你在某个情景下执行相应的操作。</span><br><span class="line"> * 接着创建一个功能类，比如这个类可以显示一个对话框、可以滑动菜单、可以下载数据等等。</span><br><span class="line"> * 然后，在这个类里面声明回调接口的对象，之后在这个类里面创建在某个情景下需要执行的方法，而且在这个方法里面为声明的接口对象赋值。</span><br><span class="line"> * 最后在其他的类中使用这个功能类就可以了。所以说，最少也是需要三个类共同来完成这个回调机制。</span><br><span class="line"> */</span><br><span class="line">public class MyDialog &#123;</span><br><span class="line">    private onButtonClick mButtonClickCallBack;</span><br><span class="line">    private Context context;</span><br><span class="line">    private String title;</span><br><span class="line">    private String message;</span><br><span class="line">    AlertDialog.Builder builderSec;</span><br><span class="line">    public interface onButtonClick&#123;</span><br><span class="line">        public void OnPositive();</span><br><span class="line">        public void OnNegative();</span><br><span class="line">    &#125;</span><br><span class="line">    public MyDialog(Context context,String title,String message)&#123;</span><br><span class="line">        this.context = context;</span><br><span class="line">        this.title = title;</span><br><span class="line">        this.message = message;</span><br><span class="line">        builderSec = new AlertDialog.Builder(context);</span><br><span class="line">        builderSec.setTitle(title);</span><br><span class="line">        builderSec.setMessage(message);</span><br><span class="line">        builderSec.setPositiveButton(&quot;确定&quot;, new DialogInterface.OnClickListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(DialogInterface dialog, int which) &#123;</span><br><span class="line"></span><br><span class="line">                mButtonClickCallBack.OnPositive();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        builderSec.setNegativeButton(&quot;取消&quot;, new DialogInterface.OnClickListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(DialogInterface dialog, int which) &#123;</span><br><span class="line">                mButtonClickCallBack.OnNegative();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        AlertDialog dialogSec = builderSec.show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setOnButtonClick(onButtonClick mNegativeCallBack) &#123;</span><br><span class="line">        this.mButtonClickCallBack = mNegativeCallBack;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>MainActivity.class</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">MyDialog deleteDialog = new MyDialog(getActivity(),&quot;RTGBrowser&quot;,&quot;是否删除当前历史记录？&quot;);</span><br><span class="line">                deleteDialog.setOnButtonClick(new MyDialog.onButtonClick() &#123;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void OnPositive() &#123;</span><br><span class="line">                        DataSupport.delete(TableHistoryLocal.class,positionInDb);</span><br><span class="line">                        queryAndTrans();</span><br><span class="line">                        roadData();</span><br><span class="line">                    &#125;</span><br><span class="line">                    @Override</span><br><span class="line">                    public void OnNegative() &#123;</span><br><span class="line">                        //donothing.</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br></pre></td></tr></table></figure></p>
<p>  水平不足，存在纰漏或错误请指教！！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/30/利用Android回调机制对Dialog进行简单封装/" data-id="cir1zx7cz001mxgyuf5bgkv43" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原创/">原创</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Fragment间的通信" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/30/Fragment间的通信/" class="article-date">
  <time datetime="2016-04-30T04:59:55.000Z" itemprop="datePublished">2016-04-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android-Google官方文档/">Android Google官方文档</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/30/Fragment间的通信/">Fragment间的通信</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>写作原因：在使用Fragment代替Activity作为整个应用的用户展示交互时大多数情况会遇到Fragment之间的通信问题，所以有必要认真对Fragment的通信进行学习。</strong><br><a href="http://developer.android.com/training/basics/fragments/communicating.html" target="_blank" rel="external">Communicating with Other Fragments</a></p>
<hr>
<p>为了重用Fragment UI组件，你应该将每个Fragment建立为完全自包含，模块化的，定义了其自身的布局和行为的组件。一旦你定义了这些可以重用的Fragments，你可以通过一个Activity和应用程序逻辑将它们联系起来从而实现总体的综合的UI设计。<br>你经常需要将一个Fragment与另一个进行交互，例如基于一个用户事件改变内容。所有的Fragment之间的通信应该通过Activity来进行。两个Fragment之间不能直接通信。</p>
<h2 id="定义一个接口"><a href="#定义一个接口" class="headerlink" title="定义一个接口"></a>定义一个接口</h2><p>为了使一个Fragment与其所属的Activity相联系，你可以在Fragment类中定义一个接口并且在Activity中实现它。Fragment在它的onAttach()生命周期中捕获接口的执行，然后调用接口方法去实现和Activity的通信。<br>下面是一个Fragment和Activity通信的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class HeadlinesFragment extends ListFragment &#123;</span><br><span class="line">    OnHeadlineSelectedListener mCallback;</span><br><span class="line"></span><br><span class="line">    // Container Activity must implement this interface</span><br><span class="line">    //在Fragment中定义一个接口</span><br><span class="line">    public interface OnHeadlineSelectedListener &#123;</span><br><span class="line">        public void onArticleSelected(int position);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onAttach(Activity activity) &#123;</span><br><span class="line">        super.onAttach(activity);</span><br><span class="line">        </span><br><span class="line">        // This makes sure that the container activity has implemented</span><br><span class="line">        // the callback interface. If not, it throws an exception</span><br><span class="line">        try &#123;</span><br><span class="line">            //在此处将activity强转成接口</span><br><span class="line">            mCallback = (OnHeadlineSelectedListener) activity;</span><br><span class="line">        &#125; catch (ClassCastException e) &#123;</span><br><span class="line">            throw new ClassCastException(activity.toString()</span><br><span class="line">                    + &quot; must implement OnHeadlineSelectedListener&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在fragment可以通过使用OnHeadlineSelectedListener接口的mCallBack实例调用onArticleSelected()方法（或接口中的其它方法）实现传递消息到Activity中。（好拗口~）<br>例如下面，当用户点击一个list item时，fragment的方法会被调用。fragment会使用callback接口去向父activity传递事件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void onListItemClick(ListView l, View v, int position, long id) &#123;</span><br><span class="line">        // Send the event to the host activity</span><br><span class="line">        mCallback.onArticleSelected(position);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="实现接口"><a href="#实现接口" class="headerlink" title="实现接口"></a>实现接口</h2><p>为了从fragment中获取回调，fragment的宿主activity必须实现fragment中定义的接口。<br>例如，上述例子中的activity中实现interface：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static class MainActivity extends Activity</span><br><span class="line">        implements HeadlinesFragment.OnHeadlineSelectedListener&#123;</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">    public void onArticleSelected(int position) &#123;</span><br><span class="line">        // The user selected the headline of an article from the HeadlinesFragment</span><br><span class="line">        // Do something here to display that article</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="传递消息到另一个Fragment"><a href="#传递消息到另一个Fragment" class="headerlink" title="传递消息到另一个Fragment"></a>传递消息到另一个Fragment</h2><p>宿主activity能够传递消息到另一个fragment通过findFragmentById()方法捕获Fragment实例，然后直接调用fragment的公共方法。<br>例如，想象一下上述的activity包含另一个通过fragmentA的item展示相关数据的fragmentB。在这个案例中，activity传递在回调方法中收到的fragmentA的信息到fragmentB然后fragmentB展示item对应的数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">public static class MainActivity extends Activity</span><br><span class="line">        implements HeadlinesFragment.OnHeadlineSelectedListener&#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    public void onArticleSelected(int position) &#123;</span><br><span class="line">        // The user selected the headline of an article from the HeadlinesFragment</span><br><span class="line">        // Do something here to display that article</span><br><span class="line"></span><br><span class="line">        ArticleFragment articleFrag = (ArticleFragment)</span><br><span class="line">                getSupportFragmentManager().findFragmentById(R.id.article_fragment);</span><br><span class="line"></span><br><span class="line">        if (articleFrag != null) &#123;</span><br><span class="line">            // If article frag is available, we&apos;re in two-pane layout...</span><br><span class="line"></span><br><span class="line">            // Call a method in the ArticleFragment to update its content</span><br><span class="line">            articleFrag.updateArticleView(position);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            // Otherwise, we&apos;re in the one-pane layout and must swap frags...</span><br><span class="line"></span><br><span class="line">            // Create fragment and give it an argument for the selected article</span><br><span class="line">            ArticleFragment newFragment = new ArticleFragment();</span><br><span class="line">            Bundle args = new Bundle();</span><br><span class="line">            args.putInt(ArticleFragment.ARG_POSITION, position);</span><br><span class="line">            newFragment.setArguments(args);</span><br><span class="line">        </span><br><span class="line">            FragmentTransaction transaction = getSupportFragmentManager().beginTransaction();</span><br><span class="line"></span><br><span class="line">            // Replace whatever is in the fragment_container view with this fragment,</span><br><span class="line">            // and add the transaction to the back stack so the user can navigate back</span><br><span class="line">            transaction.replace(R.id.fragment_container, newFragment);</span><br><span class="line">            transaction.addToBackStack(null);</span><br><span class="line"></span><br><span class="line">            // Commit the transaction</span><br><span class="line">            transaction.commit();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面是Google官方关于fragment之间通信给出的一个方案，下面贴上本人学习实现的代码，希望大神指正。<br><a href="https://github.com/VinceBarry/FraComDemo" target="_blank" rel="external">博主的github地址</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/30/Fragment间的通信/" data-id="cir1zx7cs001exgyuapf0z4cn" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/翻译/">翻译</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-一款优秀的数据集展示控件-MaterialRecents" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/26/一款优秀的数据集展示控件-MaterialRecents/" class="article-date">
  <time datetime="2016-04-26T06:55:31.000Z" itemprop="datePublished">2016-04-26</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android第三方开源库/">Android第三方开源库</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/26/一款优秀的数据集展示控件-MaterialRecents/">一款优秀的数据集展示控件-MaterialRecents</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>写作原因：最近在使用Google  Chrome浏览器时被其Tab页面所吸引，而博主正好在开发一个浏览器，所以希望将这种效果引用到自己的浏览器中，于是便搜到这款出色的控件————MaterialRecents。</strong></p>
<hr>
<p>MaterialRecents，本质上与GridView和ListView相同，用于展示数据集，具体工作原理自行阅读源码，博主就直接使用轮子啦。相比ListView和GridView，MaterialRecents有更加优秀的交互效果，博主第一眼就选择使用它来创建网页Tab页窗口。效果图如下：<br><img src="http://ww4.sinaimg.cn/mw690/a19d4f8dgw1ew38ghhcsyg205j08dqff.gif" alt="MRshow"><br>MaterialRecents地址：<a href="https://github.com/VinceBarry/MaterialRecents" target="_blank" rel="external">博主的github地址</a><br>下面稍稍讲解一下MaterialRecents的用法，因为博主github上的源代码已经很简单了，更多功能自行摸索拓展。</p>
<h2 id="配置MaterialRecents"><a href="#配置MaterialRecents" class="headerlink" title="配置MaterialRecents"></a>配置MaterialRecents</h2><p>1.导入RecentsList和RecentsAdapter<br>2.在Gradle中导入下面的依赖<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">compile &apos;com.nineoldandroids:library:2.4.0&apos;</span><br><span class="line">compile &apos;com.android.support:cardview-v7:23.2.1&apos;</span><br></pre></td></tr></table></figure></p>
<p>到此便可以开始使用MaterialRecents了。</p>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>1.为MaterialRecents引用配置Adapter，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">recentsList.setAdapter(new RecentsAdapter() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public String getTitle(int position) &#123;</span><br><span class="line">                return &quot;Title&quot; + position;</span><br><span class="line">                //每个Item的title设置</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public View getView(int position) &#123;</span><br><span class="line">                ImageView iv = new ImageView(MainActivity.this);</span><br><span class="line">                iv.setScaleType(android.widget.ImageView.ScaleType.CENTER_CROP);</span><br><span class="line">                iv.setImageResource(R.drawable.pixel01);</span><br><span class="line">                iv.setBackgroundColor(0xffffffff);</span><br><span class="line">                //Item中的显示主体View</span><br><span class="line">                return iv;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public Drawable getIcon(int position) &#123;</span><br><span class="line">                //Item的Icon设置</span><br><span class="line">                return getResources().getDrawable(R.mipmap.ic_launcher);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public int getHeaderColor(int position) &#123;</span><br><span class="line">                //标题栏颜色设置</span><br><span class="line">                return 0xffffffff;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public int getCount() &#123;</span><br><span class="line">                //Item数目设置</span><br><span class="line">                return 5;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure></p>
<p>注意与数据源绑定原理更ListView一样，这里就不多阐述了。</p>
<p>2.为Item设置监听事件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">recentsList.setOnItemClickListener(new RecentsList.OnItemClickListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onItemClick(View view, int position) &#123;</span><br><span class="line">                Toast.makeText(view.getContext(), &quot;Card &quot; + position + &quot; clicked&quot;, Toast.LENGTH_SHORT).show();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure></p>
<p>上述代码为每个Item设置监听事件，具体用法根据实际情况而定！</p>
<p>3.重构recent_card布局<br>在recent_card布局里面重新布置实现你想要的效果。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>MaterialRecents的用法还是挺简单的，但是整体效果非常令我满意，下次博主将贴出仿Chrome标签页的源代码。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/26/一款优秀的数据集展示控件-MaterialRecents/" data-id="cir1zx7cq001cxgyucqju7y1w" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原创/">原创</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-使用WebView构建网页App" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/16/使用WebView构建网页App/" class="article-date">
  <time datetime="2016-04-16T05:43:34.000Z" itemprop="datePublished">2016-04-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android-Google官方文档/">Android Google官方文档</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/16/使用WebView构建网页App/">使用WebView构建网页App</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>写作原因：最近博主打算构建一个Android Web浏览器，而作为浏览器的核心组成，WebView有必要认真学习一遍，下面是我对Google官方指南WebView的翻译，如有疏漏或错误，希望指正，另外如有转载请注明出处，谢谢！</strong><br><a href="http://developer.android.com/guide/webapps/webview.html" target="_blank" rel="external">Building Web Apps in WebView</a></p>
<hr>
<p>如果你想要搭建一个web应用（或者只是一个web页面）作为客户端程序的一个部分，你可以使用WebView来实现。WebView类是Android View类的一个继承类，使用它你可以在你的Activity布局中展示web页面。WebView没有包括任何完整的以开发完成的web浏览器的特征，诸如导航控制或者地址栏。WebView默认下是用于展示一个Web页面的。<br>一个有效的使用WebView的常见的场景是当你想要在你的应用中提供可更新的信息（例如用户协议或者指南）。在你的应用中，你可以创造一个包含WebView的Activity用于展示存在网络端的文档。<br>另一个使用场景是如果你的应用需要频繁向用户提供基于网络请求的数据（如Email）时，你可以使用。这种情况下，你会发现相比实现网络请求，解析数据然后在布局中展示，WebView方便许多。你可以为设备设计一个合理的web页面让你的应用加载web页面。<br>下面的文档向你展示了如何初步使用WebView和如何做一些额外的事情如处理页面导航和绑定来自你web页面的JavaScript到客户端app中。</p>
<p></p><h2><strong>向应用中加入WebView</strong></h2><br>简单地在布局中加入<webview>标签即可。例如，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;WebView  xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">    android:id=&quot;@+id/webview&quot;</span><br><span class="line">    android:layout_width=&quot;fill_parent&quot;</span><br><span class="line">    android:layout_height=&quot;fill_parent&quot;</span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure><p></p>
<p>通过loadUrl()方法来载入Web页面，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WebView myWebView = (WebView) findViewById(R.id.webview);</span><br><span class="line">myWebView.loadUrl(&quot;http://www.example.com&quot;);</span><br></pre></td></tr></table></figure></p>
<p>为了使上述成功执行，你的应用中需要加入网络访问权限。在manifest文件中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;manifest ... &gt;</span><br><span class="line">    &lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;/manifest&gt;</span><br></pre></td></tr></table></figure></p>
<p>以上就是一个基本展示web页面的WebView的搭建过程。</p>
<p></p><h2><strong>在WebView中使用JavaScript</strong></h2><br>如果你希望在你的WebView中使用JavaScript，你必须使WebView的JavaScript可用（enable），你可以使用WebView的getSettings()方法获得WebSettings对象，然后调用WebSettings对象的setJavaScriptEnabled(true)来使JavaScript可用。<br>例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WebView myWebView = (WebView) findViewById(R.id.webview);</span><br><span class="line">WebSettings webSettings = myWebView.getSettings();</span><br><span class="line">webSettings.setJavaScriptEnabled(true);</span><br></pre></td></tr></table></figure><p></p>
<p>WebSettings有一系列其他的有用的设置可供访问。例如，如果你在使用WebView开发一个设计方向明确的web应用，你可以通过setUserAgentSetting定义一个自定义的用户代理字符串（user agent），然后在你的web页面查询请求自定义的用户代理来核实请求你的web页面的客户端是否为你的应用。</p>
<p></p><h2><strong>绑定JavaScript到Android</strong></h2><br>当在你的Android应用中开发一个使用WebView的设计具体web应用时，你可以在你的JavaScript和Android源码之间创建接口。举个例子，你的JavaScript可以调用Android Code去展示一个Dialog，而不是使用JavaScript的alert()函数。（笔者不会JS。。。）<br>例如在你的Application中添加：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class WebAppInterface &#123;</span><br><span class="line">    Context mContext;</span><br><span class="line"></span><br><span class="line">    /** Instantiate the interface and set the context */</span><br><span class="line">    WebAppInterface(Context c) &#123;</span><br><span class="line">        mContext = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /** Show a toast from the web page */</span><br><span class="line">    @JavascriptInterface</span><br><span class="line">    public void showToast(String toast) &#123;</span><br><span class="line">        Toast.makeText(mContext, toast, Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p></p>
<p>警告：如果你设置你的targetSdkVersion为17甚至更大时，你必须添加’@JavascriptInterface annotation’到任何向JavaScript开放的方法中（此方法必为public）。如果你没有提供annotation，当你在Android4.2或更高版本运行时方法是不可见的。<br>在这个例子中，WebAppInterface类允许web页面通过使用showToast()去创造一个Toast。<br>你可以通过addJavascriptInterface()绑定这个类到在你app运行JavaScript的WebView上并且将接口命名为Android，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WebView webView = (WebView) findViewById(R.id.webview);</span><br><span class="line">webView.addJavascriptInterface(new WebAppInterface(this), &quot;Android&quot;);</span><br></pre></td></tr></table></figure></p>
<p>这样为跑在WebView上的JavaScript创造了一个名为Android的接口，你的web页面已经有权限访问WebAppInterface类，下面是通过JavaScript实现当用户点击button（Web页面）时弹出一个toast（Android）。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type=&quot;button&quot; value=&quot;Say hello&quot; onClick=&quot;showAndroidToast(&apos;Hello Android!&apos;)&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">    function showAndroidToast(toast) &#123;</span><br><span class="line">        Android.showToast(toast);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></p>
<p>没有必要在JavaScript中为Android接口初始化，WebView自动向Web页面将接口可见化。所以，一点击button，showAndroidToast() 方法使用Android接口去调用WebAppInterface.showToast()方法。<br>笔记：对象在非其构建线程中运行。<br>警告：（精简语意）Google说明通过JavaScript调用Android方法是一种危险的行为，你的Android源码可能会被攻击利用除非所有的HTML和JavaScript都在你的WebView中。</p>
<p></p><h2><strong>处理页面导航</strong></h2><br>当用户点击你WebView上面Web页面的链接时，默认行为是启动一个应用去处理URL。通常，默认的Web浏览器会打开载入目的URL。然而，你可以为你的WebView重写行为使得链接在你的WebView中打开。然后你可以允许用户在他们的历史页面间进行前进后退的导航操作。<br>为了打开用户点击的链接，只需使用setWebViewClient()为你的WebView简单地提供一个WebViewClient，例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WebView myWebView = (WebView) findViewById(R.id.webview);</span><br><span class="line">myWebView.setWebViewClient(new WebViewClient());</span><br></pre></td></tr></table></figure><p></p>
<p>现在可以实现在你的WebView上载入页面了。<br>如果你希望更多的控制一个链接启动的位置，重写shouldOverrideUrlLoading()。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private class MyWebViewClient extends WebViewClient &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean shouldOverrideUrlLoading(WebView view, String url) &#123;</span><br><span class="line">        if (Uri.parse(url).getHost().equals(&quot;www.example.com&quot;)) &#123;</span><br><span class="line">            // This is my web site, so do not override; let my WebView load the page</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line">        // Otherwise, the link is not for a page on my site, so launch another Activity that handles URLs</span><br><span class="line">        Intent intent = new Intent(Intent.ACTION_VIEW, Uri.parse(url));</span><br><span class="line">        startActivity(intent);</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><em>个人注解：如果shouldOverrideUrlLoading(WebView view, String url) 方法返回值为true则当前WebView显示，false则启动外部默认应用显示。</em><br>然后为WebView创建一个新的WebViewClient实例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WebView myWebView = (WebView) findViewById(R.id.webview);</span><br><span class="line">myWebView.setWebViewClient(new MyWebViewClient());</span><br></pre></td></tr></table></figure></p>
<p>现在当用户点击链接，系统调用shouldOverrideUrlLoading()检查URL是否为该WebView特定执行的Web页，若是则WebView内启动，否则通过intent通知外部应用（默认程序）来启动Web页。</p>
<p></p><h2><strong>网页历史导航</strong></h2><br>当你的WebView重写URL载入，它将自动积累已浏览的网页的历史记录。你可以通过goBack()和goForward()实现前后导航。<br>例如，下面是如何利用物理后退键来实现向后导航：<p></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public boolean onKeyDown(int keyCode, KeyEvent event) &#123;</span><br><span class="line">    // Check if the key event was the Back button and if there&apos;s history</span><br><span class="line">    if ((keyCode == KeyEvent.KEYCODE_BACK) &amp;&amp; myWebView.canGoBack()) &#123;</span><br><span class="line">        myWebView.goBack();</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    // If it wasn&apos;t the Back key or there&apos;s no web page history, bubble up to the default</span><br><span class="line">    // system behavior (probably exit the activity)</span><br><span class="line">    return super.onKeyDown(keyCode, event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>canGoBack()方法返回真如果真的有用户浏览记录。同样，你可以使用canGoForward()去检查是否有forward记录。如果不检查，则一旦到达历史记录的末尾，goBack()和goForward()不做任何事情。</p>
</webview>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/16/使用WebView构建网页App/" data-id="cir1zx7cx001jxgyuq8agww30" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/翻译/">翻译</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/04/12/hello-world/" class="article-date">
  <time datetime="2016-04-12T06:09:42.222Z" itemprop="datePublished">2016-04-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/04/12/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/04/12/hello-world/" data-id="cir1zx7cm0017xgyuexyl4s0y" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; __('prev')</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span>
  </nav>
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android-Google官方文档/">Android Google官方文档</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android-Studio/">Android Studio</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android-实战/">Android 实战</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android快速开发/">Android快速开发</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android知识库/">Android知识库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android第三方开源库/">Android第三方开源库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java基础知识/">Java基础知识</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux学习/">Linux学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python基础知识/">Python基础知识</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/心情随笔/">心情随笔</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/原创/">原创</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/心情/">心情</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/翻译/">翻译</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/转载/">转载</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Android/" style="font-size: 17.5px;">Android</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/Python/" style="font-size: 10px;">Python</a> <a href="/tags/原创/" style="font-size: 20px;">原创</a> <a href="/tags/心情/" style="font-size: 10px;">心情</a> <a href="/tags/翻译/" style="font-size: 12.5px;">翻译</a> <a href="/tags/转载/" style="font-size: 15px;">转载</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">六月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">五月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">四月 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/07/25/小话java多线程机制/">小话java多线程机制</a>
          </li>
        
          <li>
            <a href="/2016/07/23/小话java注解机制/">小话java注解机制</a>
          </li>
        
          <li>
            <a href="/2016/07/23/小话java反射机制/">小话java反射机制</a>
          </li>
        
          <li>
            <a href="/2016/07/19/Android自定义View系列（二）——打造一个仿2K游戏摇杆/">Android自定义View系列（二）——打造一个仿2K游戏摇杆</a>
          </li>
        
          <li>
            <a href="/2016/07/18/Android自定义View系列（一）——打造一个爱心进度条/">Android自定义View系列（一）——打造一个爱心进度条</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 陈颍聪<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>