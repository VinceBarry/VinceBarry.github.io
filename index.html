<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>RoadToGeek技术小屋（少年，别再收藏文章了！）</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="RoadToGeek技术小屋">
<meta property="og:type" content="website">
<meta property="og:title" content="RoadToGeek技术小屋（少年，别再收藏文章了！）">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="RoadToGeek技术小屋（少年，别再收藏文章了！）">
<meta property="og:description" content="RoadToGeek技术小屋">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="RoadToGeek技术小屋（少年，别再收藏文章了！）">
<meta name="twitter:description" content="RoadToGeek技术小屋">
  
    <link rel="alternate" href="/atom.xml" title="RoadToGeek技术小屋（少年，别再收藏文章了！）" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">RoadToGeek技术小屋（少年，别再收藏文章了！）</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">RoadToGeek技术小屋</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-小话java多线程机制" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/25/小话java多线程机制/" class="article-date">
  <time datetime="2016-07-25T12:09:02.000Z" itemprop="datePublished">2016-07-25</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java基础知识/">Java基础知识</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/25/小话java多线程机制/">小话java多线程机制</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>写作原因：对于并发编程一块，是编程中的一道坎，对于它的理解有一定难度。所以本文作者只能略作皮毛分享，对于深层学习仍在途中。希望读者能够多多交流</strong></p>
<h2 id="线程初识"><a href="#线程初识" class="headerlink" title="线程初识"></a>线程初识</h2><p>先了解一下线程、进程、并发、并行的概念。进程顾名思义，就是进行中的程序，线程是进程中可以独立并发执行的基本单元。进程中包括内存和线程两块，内存是存储资源，线程是进程内部各个功能的分载体，进程内所有线程都享有进程的共享内存，此外线程有各自的独立工作内存。这些细节在下面的锁机制中进行分析。</p>
<h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><p>java中创建一个线程并不难，有下面两种方式：直接使用Thread创建，实现Runnable接口然后注入Thread中创建。由于相对简单，这里不多加阐述。</p>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>一个线程包括下面几个生命周期：新建、可运行（启动线程）、运行（系统调度）、阻塞/等待、消亡（退出run）。新建一个线程就是指我们写完一个线程并将它实例化对象的过程，可运行其实就是使用start()方法的过程，注意调用start()方法后不一定开始运行，因为线程的运行受到系统的调度。运行过程是线程真正运行的过程，当调用sleep()、suspend()、wait()时或者线程执行IO操作时会让出CPU中止执行，进入阻塞和等待过程；当run()方法结束后进入死亡状态。</p>
<h2 id="常见API"><a href="#常见API" class="headerlink" title="常见API"></a>常见API</h2><p>这里介绍几个常用的API：<br>类方法：currentThread()获取当前类对象、yield()线程礼让、sleep()线程休眠<br>setDaemon():设置守护线程（幽灵）。守护线程的特点：当其它线程中止时，守护线程自动消亡。</p>
<h2 id="线程数据共享问题"><a href="#线程数据共享问题" class="headerlink" title="线程数据共享问题"></a>线程数据共享问题</h2><p>下面开始阐述线程同步的问题。线程同步很重要，因为一个进程内多个线程的数据经常需要共享使用。然而如果在不知道任何关于线程同步的操作的情况下直接进行线程间数据的共享，那样是很危险的。为什么不能直接进行线程之间的数据共享呢？我们都知道每个线程有它们独立的工作内存，这说明线程操作共享内存是间接的，也就是说某个线程对主工作内存刷新后另一个工作内存可能不知道，那么你直接操作拿到的数据可能就过时了，这样共享就失败了。此外，由于多个线程可能同时进行，内部操作某个共有的变量时顺序可能会出现多种不同的顺序，即指令重排序问题。比如说A线程，B线程，如果A线程和B线程内部多次操作C变量，这时就会出现混乱的排序问题。如果解决了以上两个问题就解决了线程数据共享问题。下面引入synchronized关键字。</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>java提供了锁机制（mutex），每次只允许一个线程访问一块共享内存。对于加锁有两种形式，一种是使用代码块对某个共享的变量进行加锁，另一种是直接对方法进行加锁，对方法进行加锁实际上是以成员方法所在的对象本身作为对象锁。下面通过一个例子来认识synchronized关键字：<br>Data类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Data &#123;</span><br><span class="line">    static int i;</span><br><span class="line">    public static synchronized void add()&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Thread.sleep(500);</span><br><span class="line">        &#125; catch (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        i++;</span><br><span class="line">        System.out.println(&quot;i:&quot;+i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ThreadA:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class ThreadA extends Thread&#123;</span><br><span class="line">    private Data data;</span><br><span class="line">    public ThreadA(String name,Data data)&#123;</span><br><span class="line">        super(name);</span><br><span class="line">        this.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">    public void run()&#123;</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            data.add();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Main.java:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        for(int i=0;i&lt;10;i++)&#123;</span><br><span class="line">            Data data = new Data();</span><br><span class="line">            new ThreadA(&quot;Thread&quot;+i,data).start();</span><br><span class="line">        &#125;</span><br><span class="line">        Data data = new Data();</span><br><span class="line">        while(true)&#123;</span><br><span class="line">            data.add();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Main中新建了十个子线程，每个子线程中都可以执行add()方法使i变量增大，我们使用synchronized关键字修饰add()静态方法，就是表明Data类的类实例被用作对象锁了。也就是data被锁住了，其它线程操作data时只能一次一个操作。所以如果你将synchronized关键字加在run()方法上就是无效的，因为这时锁住的对象是线程对象，线程对象是多变的，而非共享的区域。使用synchronized后线程执行互斥代码时大致过程是这样的：先获得互斥锁，然后清空工作内存，从主内存中拷贝变量的最新副本，执行代码，然后将更改后的共享变量的值刷新到主内存中，最后释放互斥锁。这样就实现了线程间共享数据逻辑。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关于多线程这一大块是硬骨头，很难真正把它啃下来。文中还有许多地方没有涉及，而且由于是个人理解可能存在疏漏，后续在进行Android线程剖析时再做补充。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/07/25/小话java多线程机制/" data-id="cir1zx7di0021xgyuq536g47t" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原创/">原创</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-小话java注解机制" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/23/小话java注解机制/" class="article-date">
  <time datetime="2016-07-23T02:59:28.000Z" itemprop="datePublished">2016-07-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java基础知识/">Java基础知识</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/23/小话java注解机制/">小话java注解机制</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>写作原因：Java反射注解这一块一直是笔者的盲区，但是Java系开发者都知道这一块的重要性。以熟悉的Android开发为例，通过利用反射注解大神们创造了可以减少大量重复赘余代码和清晰逻辑结构的依赖注入框架。本文也是为日后的依赖注入剖析做预备。由于水平限制，一些地方可能存在疏漏，望指出。</strong></p>
<hr>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>本章继续探讨反射注解的相关知识。上一章分享了关于反射的一些内容，相比反射注解内容少许多。直接开始正文吧。什么是注解？注解就是描述代码的东东，比如我们常见的@Override，它就是描述一个方法说明该方法是重写父类的方法。再比如@Deprecated就是说明一个方法过时了（那些调用时打横线的方法就是过时的方法，就是该注解的功劳）；还有@SuppressWarnings(“XXX”)就是用来忽略各种警告的。好了，我顺便把<strong>官方的注解</strong>也在讲定义的时候说明了。下面看看自定义注解和第三方注解（实际上就是自定义注解）。</p>
<h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><p>自定义注解格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Target(ElementType.METHOD)</span><br><span class="line">//作用域，包括方法、成员、构造函数等几乎所有地方</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">//生命周期，注明注解起效果的时间，SOURCE（源码阶段），CLASS（编译阶段），RUNTIME（运行阶段）</span><br><span class="line">@Inherited</span><br><span class="line">@Documented</span><br><span class="line">public @interface Description &#123;</span><br><span class="line">    String value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面四个称为元注解（注解的注解），功能见注释，主要说明一下@Inherited，如果在一个父类中某个地方使用该注解，那么继承该父类的子类中该注解也会起效果。@Documented用于在javadoc中为注解输出信息。注解中只有一个成员时最好用value作为成员名，多个时随意，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public @interface Description&#123;</span><br><span class="line">	String desc();//成员以无参无异常的方式声明</span><br><span class="line">	String author();</span><br><span class="line">	int age() default 18;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意成员类型包括基本类型，String，Class，Annotation，Enumeration。也可以没有成员，那叫标示注解。<br>使用自定义注解时在作用域上方写，格式如下：<br><code>@Description(desc=&quot;am&quot;,author=&quot;Mooc&quot;,age=18)</code></p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>个人感觉解析注解是注解最有趣的地方，利用好这个东西可以实现许多代码的优化，具体实现是通过反射进行的，如果对于反射不清楚的可以参考上一篇文章。下面我们写一个注解解释器解释方法上面的注解，代码见下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class DescriptionWorker &#123;</span><br><span class="line">    public static void work()&#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Class c = Class.forName(&quot;com.vince.reflect.ClassInfo&quot;);</span><br><span class="line">            Method[] ms = c.getMethods();</span><br><span class="line">            for(Method m:ms)&#123;</span><br><span class="line">                boolean isExist = m.isAnnotationPresent(Description.class);</span><br><span class="line">                if(isExist)&#123;</span><br><span class="line">                    Description d = (Description) m.getAnnotation(Description.class);</span><br><span class="line">                    System.out.println(d.value());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>先获取方法然后判断类内部是否有注解，如果有将方法上的注解取出将值打印出来，这就是方法解释器的运行原理。基本都是反射的原理，主要要注意<code>isAnnotationPresent(Description.class);</code>和<code>m.getAnnotation(Description.class)</code>。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关于对注解价值的认识得结合一些实际代码来分析，之后博主将会结合实战剖析重新认识注解。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/07/23/小话java注解机制/" data-id="cir1zx7eu0041xgyumm8eth17" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原创/">原创</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-小话java反射机制" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/23/小话java反射机制/" class="article-date">
  <time datetime="2016-07-23T02:16:27.000Z" itemprop="datePublished">2016-07-23</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Java基础知识/">Java基础知识</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/23/小话java反射机制/">小话java反射机制</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>写作原因：Java反射注解这一块一直是笔者的盲区，但是Java系开发者都知道这一块的重要性。以熟悉的Android开发为例，通过利用反射注解大神们创造了可以减少大量重复赘余代码和清晰逻辑结构的依赖注入框架。本文也是为日后的依赖注入剖析做预备。由于水平限制，一些地方可能存在疏漏，望指出。</strong></p>
<hr>
<p>本章先从反射开始吧。java是一门面向对象的语言，java中有一句话概括了这个特点：万物皆对象。平常我们创建的对象是通过某个类产生的，那么类本身呢？不是说万物皆对象吗？还有基本对象和静态成员变量呢？于是java中便引入定义：类本身也是Class类的实例对象。Class普通类是Class类的对象。一切操作都将使用Object完成，类、数组的引用都可以使用Object进行接收。这就真正实现了万物皆对象的思想。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>那么一个类作为一个对象这个怎么定义呢？有如下三种方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Person person = new Person();</span><br><span class="line">Class c1 = Person.class;</span><br><span class="line">//这个实例化说明每个类都有一个静态的成员变量Class;</span><br><span class="line">class c2 = person.getClass();</span><br><span class="line">//通过某个类的对象来获得这个对象的类类型；</span><br><span class="line">Class c3 = Class.forName(&quot;类的具体名&quot;);</span><br><span class="line">//通过类的具体名称（包括包名）来获得；</span><br></pre></td></tr></table></figure>
<p>注意上面c1、c2、c3是相等的，他们都是指向Person这个Class类实例化的对象的。现在我们有了类这个对象（好绕口，其实我们现在要做的就是把所有都看成对象，包括类），我们能做什么呢？我们可以通过这个类对象来调用Class类的方法来实现一些功能。具体有哪些功能呢？</p>
<h2 id="实现动态加载类的功能"><a href="#实现动态加载类的功能" class="headerlink" title="实现动态加载类的功能"></a>实现动态加载类的功能</h2><p>由于反射是在编译之后进行的，所以可以通过反射来绕过编译期加载类，实现运行时动态加载类的效果。这样有什么好处呢？通过动态加载类，我们可以完成功能模块的更新而不需重新编译，在需要某个模块时可以动态添加。具体操作我们通过一个Demo来呈现。下面展示一下这个Demo，比如我们要写一个QQ，除了聊天功能（固定，这里我们使用静态加载作比较），我们还提供各种其他功能供用户选择安装使用，比如QQMusic和QQHealth，用户根据需要安装使用。如果使用静态加载类，要实现以上功能我们只能一次性全部把功能写到QQ这个程序里面，而且就算写进去了日后要升级还是得重新再源代码里面添加加载类，这样及其不合理。这时使用反射动态加载就十分必要了。下面我们写一下这个例子，该例子共有5个类，分别为QQ.java、QQChat.java、QQHealth.java、QQMusic.java、FuncAble.java：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class QQ &#123;</span><br><span class="line">    public static void main(String args[])&#123;</span><br><span class="line">        QQChat chat = new QQChat();</span><br><span class="line">        chat.run();</span><br><span class="line">        //</span><br><span class="line">        System.out.println(&quot;Please input the application you want to open:&quot;);</span><br><span class="line">        Scanner s = new Scanner(System.in);</span><br><span class="line">        String name = s.next();</span><br><span class="line">        try &#123;</span><br><span class="line">            Class health = Class.forName(name);</span><br><span class="line">            FuncAble fa = (FuncAble) health.newInstance();</span><br><span class="line">            fa.run();</span><br><span class="line">        &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (InstantiationException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; catch (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>QQ.java中实现了静态加载聊天功能和动态加载其它功能的逻辑。我们根据用户输入的类名来加载类类型并实例化为对象然后调用对象的方法，注意我们使用了FuncAble这个接口。为什么要使用接口呢？这里利用了多态性，通过使用接口来兼容各个类对象的实例化。这样下次在增加新的类功能模块时就不用重新去写QQ类的内部逻辑了，只需实现FuncAble接口然后写我们需要的类的逻辑就行了。</p>
<h2 id="获取类内部信息"><a href="#获取类内部信息" class="headerlink" title="获取类内部信息"></a>获取类内部信息</h2><p>大家一定很好奇IDE的只能提示是怎么实现的吧？没错，它们也是利用反射机制完成的。下面我展示一下利用反射来模拟IDE的智能提示功能。这里我们写了一个类名叫ClassInfo，用该类来获取类的内部信息，详细方法见代码中的注释。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">public class ClassInfo &#123;</span><br><span class="line">	//获取方法信息    </span><br><span class="line">	public static void getMethodInfo(Object obj)&#123;</span><br><span class="line">        Class c = obj.getClass();</span><br><span class="line">		//获取类类型</span><br><span class="line">        Method[] ms = c.getDeclaredMethods();</span><br><span class="line">		//获取方法对象数组</span><br><span class="line">        for(Method m : ms)&#123;</span><br><span class="line">            String modifierName = Modifier.toString(m.getModifiers());</span><br><span class="line">			//获取修饰符</span><br><span class="line">            String methodName = m.getName();</span><br><span class="line">			//获取方法名</span><br><span class="line">            Class[] paraTypes = m.getParameterTypes();</span><br><span class="line">			//获取形参类类型</span><br><span class="line">            String paraTypeName = &quot;&quot;;</span><br><span class="line">            for(Class para : paraTypes)&#123;</span><br><span class="line">                paraTypeName= paraTypeName + &quot; &quot;+para.getSimpleName();</span><br><span class="line">            &#125;</span><br><span class="line">            Class returnType = m.getReturnType();</span><br><span class="line">            String returnTypeName = returnType.getSimpleName();</span><br><span class="line">			//获取返回类型</span><br><span class="line">            //也可以使用getName(),不过会包含包名</span><br><span class="line">            System.out.println(modifierName +&quot; &quot;+returnTypeName+&quot; &quot;+methodName+&quot;(&quot;+paraTypeName+&quot;)&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	//获取成员信息 </span><br><span class="line">    public static void getFieldInfo(Object obj)&#123;</span><br><span class="line">        Class c = obj.getClass();</span><br><span class="line">        Field[] fields = c.getDeclaredFields();</span><br><span class="line">		//获取成员对象数组</span><br><span class="line">        for(Field f : fields)&#123;</span><br><span class="line">            String fieldName = f.getName();</span><br><span class="line">			//获取成员名</span><br><span class="line">            Class fieldType = f.getType();</span><br><span class="line">			//获取成员类类型</span><br><span class="line">            int modifier = f.getModifiers();</span><br><span class="line">			//获取修饰符</span><br><span class="line">            String modifierName = Modifier.toString(modifier);</span><br><span class="line">            String fieldTypeName = fieldType.getSimpleName();</span><br><span class="line">            System.out.println(modifierName+&quot; &quot; + fieldTypeName + &quot; &quot;+fieldName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	//获取构造函数信息 </span><br><span class="line">    public static void getConstructorInfo(Object obj)&#123;</span><br><span class="line">        Class c = obj.getClass();</span><br><span class="line">        Constructor[] constructors = c.getDeclaredConstructors();</span><br><span class="line">		//获取构造函数对象数组</span><br><span class="line">        for(Constructor constructor : constructors)&#123;</span><br><span class="line">            String constructorName = constructor.getName();</span><br><span class="line">			//获取构造函数名</span><br><span class="line">            String paraTypeName = &quot;&quot;;</span><br><span class="line">            Class[] paraTypes = constructor.getParameterTypes();</span><br><span class="line">			//获取形参类类型</span><br><span class="line">            for(Class p : paraTypes)&#123;</span><br><span class="line">                paraTypeName = paraTypeName+&quot; &quot;+p.getSimpleName()+&quot; &quot;;</span><br><span class="line">				//获取形参类型名</span><br><span class="line">            &#125;</span><br><span class="line">            String modifierName = Modifier.toString(c.getModifiers());</span><br><span class="line">            System.out.println(modifierName+&quot; &quot;+constructorName+&quot;(&quot;+paraTypeName+&quot;)&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有了这个类，我们就可以根据某个类的实例对象查看该类的方法，成员及构造函数了。</p>
<h2 id="通过反射操作类内部"><a href="#通过反射操作类内部" class="headerlink" title="通过反射操作类内部"></a>通过反射操作类内部</h2><p>这里讲述通过反射操作方法的例子，修改成员变量类似。还记得以前我剖析过鸿洋大神对SP的封装工具类SPUtils。他就是通过反射将SP.Editor里面的apply()方法取出然后调用实现将IO操作异步进行的工作（commit是同步的）。首先应该知道：方法名称和方法的参数列表唯一决定方法。所以我们可以通过类类型的<code>getMethod(name,parameterTypes)</code>获得唯一方法，然后通过方法对象的<code>invoke(对象，参数列表)</code>来实现方法间接操作对象从而调用方法。代码片段见下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">获取方法：名称参数列表</span><br><span class="line">//getDeclaredMethod()</span><br><span class="line">a1 = c.getMethod(name,parameterTypes)</span><br><span class="line">parameterTypes = new Class[]&#123;int.class,int class&#125;;//int.class,int.class</span><br><span class="line">Object o = a1.invoke(对象，new Object[]&#123;10,20&#125;)//方法操作对象(或者对象，10,20)</span><br><span class="line">方法如果没有返回值返回null，有返回值返回具体的值</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后回答一下前面那个问题：基本数据类型跟void关键字也是类类型，数组也一样。就是说它们也可以是对象，如int.class等。博主写这篇文章真是几经周折，先是eclipse崩溃，然后使用Atom写文章，文章写完后Atom挂掉了……又重写了一遍。不说了，都是泪。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/07/23/小话java反射机制/" data-id="cir1zx7de001xxgyul9bd3zd1" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原创/">原创</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Android自定义View系列（二）——打造一个仿2K游戏摇杆" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/19/Android自定义View系列（二）——打造一个仿2K游戏摇杆/" class="article-date">
  <time datetime="2016-07-19T09:23:02.000Z" itemprop="datePublished">2016-07-19</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android-实战/">Android 实战</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/19/Android自定义View系列（二）——打造一个仿2K游戏摇杆/">Android自定义View系列（二）——打造一个仿2K游戏摇杆</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>写作原因：Android进阶过程中有一个绕不开的话题——自定义View。这一块是安卓程序员更好地实现功能自主化必须迈出的一步。下面这个系列博主将通过实现几个例子来认识安卓自定义View的方法。从自定义View到自定义ViewGroup，View事件处理再到View深入分析（这一章如果水平未到位可能今后再补充），其中会涉及一些小的知识，包括Canvas的使用、动画等等。这是本系列的第二章，博主将通过定制一个摇杆的实例巩固上章的知识，并引入自定义View中实现用户交互和数据回调两个方面的功能。此外在本章中我们将看到数学知识（尤其是三角函数）在自定义View中的重要作用（这也是本例的一个难点），下面开始解放大脑和双手吧。</strong></p>
<h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><p>本例的最终效果如下：</p>
<p><img src="http://7xszli.com1.z0.glb.clouddn.com/customview3.gif" alt="效果"></p>
<p>这就是本例的最终效果，我们将实现一个虚拟游戏方向摇杆，模拟摇杆操作。此外我们将为它写一个监听器实现摇动方向和速度等数据返回（本例中只实现了监听部分代码，数据读者可以自行加上）。</p>
<h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><p>首先依然是上一篇所讲述的那几个步骤，包括自定义XML属性，引入属性，测量和绘制几个部分（没看过上一篇文章的点击博客阅读或者查看博主的简书），除了这几个部分外我们还需要重写onTouchEvent()方法进行View事件处理和利用回调写好监听器。整体思路就是这样，看起来不难，实际操作起来陷阱多多。</p>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><p>新建value/attrs.xml，在XML中声明并引入以下属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;resources&gt;</span><br><span class="line">    &lt;attr name=&quot;InnerColor&quot; format=&quot;color&quot;/&gt;</span><br><span class="line">    &lt;attr name=&quot;OuterColor&quot; format=&quot;color&quot;/&gt;</span><br><span class="line">    &lt;declare-styleable name=&quot;NavController&quot;&gt;</span><br><span class="line">        &lt;attr name=&quot;InnerColor&quot; /&gt;</span><br><span class="line">        &lt;attr name=&quot;OuterColor&quot;/&gt;</span><br><span class="line">    &lt;/declare-styleable&gt;</span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure></p>
<p>这次我们只需要两个属性，小圆颜色和大圆颜色。然后新建一个java文件，继承View命名为NavController，在java中重写构造方法并且将XML属性导入，新建画笔对象，为之设置好属性。关键代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public NavController(Context context, AttributeSet attrs) &#123;</span><br><span class="line">    super(context, attrs);</span><br><span class="line">    TypedArray ta = getResources().obtainAttributes(attrs,R.styleable.NavController);</span><br><span class="line">    innerColor = ta.getColor(R.styleable.NavController_InnerColor,INNER_COLOR_DEFAULT);</span><br><span class="line">    outerColor = ta.getColor(R.styleable.NavController_OuterColor,OUTER_COLOR_DEFAULT);</span><br><span class="line">    ta.recycle();</span><br><span class="line">    OUTER_WIDTH_SIZE = dip2px(context,125.0f);</span><br><span class="line">    OUTER_HEIGHT_SIZE = dip2px(context,125.0f);</span><br><span class="line">    outerPaint = new Paint();</span><br><span class="line">    innerPaint = new Paint();</span><br><span class="line">    outerPaint.setColor(outerColor);</span><br><span class="line">    outerPaint.setStyle(Paint.Style.FILL_AND_STROKE);</span><br><span class="line">    innerPaint.setColor(innerColor);</span><br><span class="line">    innerPaint.setStyle(Paint.Style.FILL_AND_STROKE);</span><br></pre></td></tr></table></figure></p>
<p>上面的OUTER_WIDTH_SIZE和OUTER_HEIGHT_SIZE分别是大圆在没有设置具体值下的默认大小，我们使用dip2px()方法将我们熟练掌握的dip转化为java逻辑唯一承认的px单位，具体实现：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public static int dip2px(Context context, float dpValue)&#123;</span><br><span class="line">        final float scale = context.getResources().getDisplayMetrics().density;</span><br><span class="line">        return (int) (dpValue*scale +0.5f);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>这样就做好了前期准备工作，由于上篇讲述过关于onMeasure和onDraw的相关理解和用法，这里就简单阐述，将这两块写在同一个部分。</p>
<h3 id="测量绘制"><a href="#测量绘制" class="headerlink" title="测量绘制"></a>测量绘制</h3><p>测量时我们分别对三种模式下的尺寸进行不同的处理，分别是返回父View给的值加上padding值（EXACTLY），返回大圆的宽高（UNSPECIFIED）和返回大圆宽高与父View允许最大值之间的最小值（AT_MOST）。然后回调onSizeChanged()中取出实际宽高值，利用该值进行View绘制。onDraw中主要是确定了两个圆的半径（大圆半径为去除padding的宽高一半下四种情况的最小值，参照代码看这句话。小圆半径为大圆的一半）和绘制了两个圆。此外小圆的中心点我们现在onSizeChanged中进行了赋值，注意小圆中心点坐标值的改变是本例的关键，通过改变它来实现效果。这样我们就把View的显示区域和View的基本形状定义完毕。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">        super.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">        int width = measureWidth(widthMeasureSpec);</span><br><span class="line">        int height = measureHeight(heightMeasureSpec);</span><br><span class="line">        setMeasuredDimension(width,height);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int measureWidth(int widthMeasureSpec) &#123;</span><br><span class="line">        int widthMode = MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line">        int widthVal = MeasureSpec.getSize(widthMeasureSpec);</span><br><span class="line">        //处理三种模式</span><br><span class="line">        if(widthMode==MeasureSpec.EXACTLY)&#123;</span><br><span class="line">            return widthVal+getPaddingLeft()+getPaddingRight();</span><br><span class="line">        &#125;else if(widthMode==MeasureSpec.UNSPECIFIED)&#123;</span><br><span class="line">            return OUTER_WIDTH_SIZE;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return Math.min(OUTER_WIDTH_SIZE,widthVal);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private int measureHeight(int heightMeasureSpec) &#123;</span><br><span class="line">        int heightMode = MeasureSpec.getMode(heightMeasureSpec);</span><br><span class="line">        int heightVal = MeasureSpec.getSize(heightMeasureSpec);</span><br><span class="line">        //处理三种模式</span><br><span class="line">        if(heightMode==MeasureSpec.EXACTLY)&#123;</span><br><span class="line">            return heightVal+getPaddingTop()+getPaddingBottom();</span><br><span class="line">        &#125;else if(heightMode==MeasureSpec.UNSPECIFIED)&#123;</span><br><span class="line">            return OUTER_HEIGHT_SIZE;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return Math.min(OUTER_HEIGHT_SIZE,heightVal);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123;</span><br><span class="line">        super.onSizeChanged(w, h, oldw, oldh);</span><br><span class="line">        realWidth = w;</span><br><span class="line">        realHeight = h;</span><br><span class="line">        innerCenterX = realWidth/2;</span><br><span class="line">        innerCenterY = realHeight/2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onDraw(Canvas canvas) &#123;</span><br><span class="line">        super.onDraw(canvas);</span><br><span class="line">        outRadius = Math.min(Math.min(realWidth/2-getPaddingLeft(),realWidth/2-getPaddingRight()),Math.min(realHeight/2-getPaddingTop(),realHeight/2-getPaddingBottom()));</span><br><span class="line">        //画外部圆</span><br><span class="line">        canvas.drawCircle(realWidth/2,realHeight/2,outRadius,outerPaint);</span><br><span class="line">        //内部圆</span><br><span class="line">        innerRedius = outRadius*0.5f;</span><br><span class="line">        canvas.drawCircle(innerCenterX,innerCenterY,innerRedius,innerPaint);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="View事件处理"><a href="#View事件处理" class="headerlink" title="View事件处理"></a>View事件处理</h3><p>下面这一步是实现效果的关键步骤。上面我们已经绘制出了基本的形状，但是View触摸后没有任何效果。这一步正是实现View触摸的效果。对于这一步的理解可能有一定的难度，读者应该反复揣摩其中涉及到基本的三角函数和圆的方程的计算，如果不明白这两部分数学知识的最好先去翻一翻课本……定义一些炫酷的View大都基于数学知识的基础上。我们要重写onTouchEvent()方法，先放上这部分代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public boolean onTouchEvent(MotionEvent event) &#123;</span><br><span class="line">        if(event.getAction()==MotionEvent.ACTION_DOWN)&#123;</span><br><span class="line">            changeInnerCirclePosition(event);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        if(event.getAction()==MotionEvent.ACTION_MOVE)&#123;</span><br><span class="line">            changeInnerCirclePosition(event);</span><br><span class="line">            Log.i(&quot;TAG&quot;,&quot;MOVED&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if(event.getAction()==MotionEvent.ACTION_UP)&#123;</span><br><span class="line">            innerCenterX = realWidth/2;</span><br><span class="line">            innerCenterY = realHeight/2;</span><br><span class="line">            invalidate();</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到，上面的对onTouchEvent()方法的重写处理了三种情况下的逻辑：用户在View的区域按下、移动和离开三种情况，当手指离开时我们把内圆的中心点移动到View的最中间（恢复初始状态），然后刷新，当按下或者移动时调用changeInnerCirclePosition(event)方法，这个方法用于对内圆进行处理让内圆根据手指位置判断调整位置。<br>下面看看changeInnerCirclePosition()方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">private void changeInnerCirclePosition(MotionEvent e) &#123;</span><br><span class="line">        //圆的方程：（x-realWidth/2）^2 +（y - realHeight/2）^2 &lt;= outRadius^2</span><br><span class="line">        //第一步，确定有效的触摸点集</span><br><span class="line">        float X = e.getX();</span><br><span class="line">        float Y = e.getY();</span><br><span class="line">        if(mCallBack!=null)&#123;</span><br><span class="line">            mCallBack.onNavAndSpeed(X,Y);</span><br><span class="line">        &#125;</span><br><span class="line">        boolean isPointInOutCircle = Math.pow(X-realWidth/2,2) +Math.pow(Y-realHeight/2,2)&lt;=Math.pow(outRadius,2);</span><br><span class="line">        if(isPointInOutCircle)&#123;</span><br><span class="line">            Log.i(&quot;TAG&quot;,&quot;inCircle&quot;);</span><br><span class="line">            //两种情况：小圆半径</span><br><span class="line">            boolean isPointInFree = Math.pow(X-realWidth/2,2) +Math.pow(Y-realHeight/2,2)&lt;=Math.pow(outRadius-innerRedius,2);</span><br><span class="line">            if(isPointInFree)&#123;</span><br><span class="line">                innerCenterX = X;</span><br><span class="line">                innerCenterY = Y;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                //处理限制区域，这部分使用触摸点与中心点与外圆方程交点作为内圆的中心点</span><br><span class="line">                //使用近似三角形来确定这个点</span><br><span class="line">                //求出触摸点，触摸点垂足和中心点构成的直角三角形（pointTri）的直角边长</span><br><span class="line">                float pointTriX = Math.abs(realWidth/2-X);//横边</span><br><span class="line">                float pointTriY = Math.abs(realHeight/2-Y);//竖边</span><br><span class="line">                float pointTriZ = (float) Math.sqrt((Math.pow(pointTriX,2)+Math.pow(pointTriY,2)));</span><br><span class="line">                float TriSin = pointTriY/pointTriZ;</span><br><span class="line">                float TriCos = pointTriX/pointTriZ;</span><br><span class="line">                //求出在圆环上的三角形的两个直角边的长度</span><br><span class="line">                float limitCircleTriY = (outRadius-innerRedius)*TriSin;</span><br><span class="line">                float limitCircleTriX = (outRadius-innerRedius)*TriCos;</span><br><span class="line">                //确定内圆中心点的位置，分四种情况</span><br><span class="line">                if(X&gt;=realWidth/2 &amp;&amp; Y&gt;=realHeight/2)&#123;</span><br><span class="line">                    innerCenterX = realWidth/2+limitCircleTriX;</span><br><span class="line">                    innerCenterY = realHeight/2+limitCircleTriY;</span><br><span class="line">                &#125;else if(X&lt;realWidth/2 &amp;&amp; Y&gt;=realHeight/2)&#123;</span><br><span class="line">                    innerCenterX = realWidth/2-limitCircleTriX;</span><br><span class="line">                    innerCenterY= realHeight/2+limitCircleTriY;</span><br><span class="line">                &#125;else if(X&gt;=realWidth/2 &amp;&amp; Y&lt;realHeight/2)&#123;</span><br><span class="line">                    innerCenterX = realWidth/2+limitCircleTriX;</span><br><span class="line">                    innerCenterY= realHeight/2-limitCircleTriY;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    innerCenterX = realWidth/2-limitCircleTriX;</span><br><span class="line">                    innerCenterY= realHeight/2-limitCircleTriY;</span><br><span class="line">                &#125;</span><br><span class="line">                Log.i(&quot;TAG&quot;,&quot;inLimit&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            invalidate();</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            Log.i(&quot;TAG&quot;,&quot;notInCircle&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>这个方法很长，上面我已经说了，它是用于让内圆根据用户的手指的位置进行位置变动的关键。下面一步一步剖析。附上本人实现过程中绘制的图片。建议在实现一些逻辑时可以绘图帮助记录和启发思维。</p>
<p><img src="http://7xszli.com1.z0.glb.clouddn.com/customview4.PNG" alt="分析图"></p>
<p><strong>第一步，我们先获取有效的触摸范围（根据个人实际情况而定）</strong></p>
<p>本例中博主不使用希望用户在点击大圆外面的范围时内圆还跟着运动，所以要先确定一下触摸的有效范围。<br>使用圆的方程来判断用户的触摸点是否在大圆内，代码：<code>boolean isPointInOutCircle = Math.pow(X-realWidth/2,2) +Math.pow(Y-realHeight/2,2)&lt;=Math.pow(outRadius,2);</code>。如果不在大圆内不执行逻辑，在大圆内则进行下一步判断。</p>
<p><strong>第二步，触摸点是否在自由域内？</strong></p>
<p>这里博主使用了自由域这个词（好吧，自己扯的）。以大圆半径减去小圆半径后的值作为半径生成新的圆（命名为<strong>限制圆</strong>，下面用到），我把下图中S1部分叫做自由域，S2为非自由域。</p>
<p><img src="http://7xszli.com1.z0.glb.clouddn.com/customview5.PNG" alt="自由域"></p>
<p>自由域有什么特点？就是当用户把触摸点落在自由域内我们小圆的中心点只要跟着触摸点的坐标就行了，没有任何限制；而当落在非自由域内时小圆的中心点就受到限制了。这里分成两部分讨论。对于自由域的处理见下面：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if(isPointInFree)&#123;</span><br><span class="line">                innerCenterX = X;</span><br><span class="line">                innerCenterY = Y;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure></p>
<p>对于非自由域我们怎么处理呢？当用户触摸点落在非自由域时，我们把触摸点与限制圆作为小圆中心点的坐标，见下图展示：</p>
<p><img src="http://7xszli.com1.z0.glb.clouddn.com/customview6.PNG" alt="非自由域处理"></p>
<p>下面就是求解直线与圆的交点坐标的问题了（博主整整搞了一个小时……），只要解决这个问题即可，不过要注意这里的坐标与数学的坐标系略有不同，横轴为x向右，纵轴为y向下。我的处理方式见上面代码，主要利用相似三角形和三角函数的知识。具体注解上面有表述。这一步跟绘制往往表现了一个自定义View的质量高低。</p>
<h3 id="监听器的构造"><a href="#监听器的构造" class="headerlink" title="监听器的构造"></a>监听器的构造</h3><p>有了这个摇杆，最后就是为它实现返回数据的功能了，我们使用监听器来实现。（可以参考<a href="http://roadtogeek.cn/2016/04/30/%E5%88%A9%E7%94%A8Android%E5%9B%9E%E8%B0%83%E6%9C%BA%E5%88%B6%E5%AF%B9Dialog%E8%BF%9B%E8%A1%8C%E7%AE%80%E5%8D%95%E5%B0%81%E8%A3%85/" target="_blank" rel="external">利用Android回调机制对Dialog进行简单封装</a>关于回调监听的知识）先写好监听的回调接口，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface OnNavAndSpeedListener&#123;</span><br><span class="line">        public void onNavAndSpeed(float nav,float speed);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>声明接口对象mCallBack，然后在需要回调返回数据的地方调用改接口中的方法：<code>mCallBack.onNavAndSpeed(float nav,float speed)</code>，注意先判断mCallBack对象是否为null。然后使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void setOnNavAndSpeedListener(OnNavAndSpeedListener listener)&#123;</span><br><span class="line">        mCallBack = listener;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>在Activity中让调用者新建接口并传入。Activity中具体使用如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">navController.setOnNavAndSpeedListener(new NavController.OnNavAndSpeedListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onNavAndSpeed(float nav, float speed) &#123;</span><br><span class="line">                Log.i(&quot;TAG&quot;,nav+speed+&quot;&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure></p>
<p>这样就实现了速度和方向的返回，定制完了一个游戏摇杆。读者可以根据需求进行优化更改。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本章借助实现游戏摇杆的例子回顾了自定义View的基本步骤和引入事件处理和监听器的相关实现，下面的文章将对ViewGroup一块开始动刀子学习。如果感觉对您有帮助可以关注本人博客或者简书。</p>
<h2 id="附录：View具体代码"><a href="#附录：View具体代码" class="headerlink" title="附录：View具体代码"></a>附录：View具体代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line">public class NavController extends View &#123;</span><br><span class="line">    private int innerColor;</span><br><span class="line">    private int outerColor;</span><br><span class="line">    private final static int INNER_COLOR_DEFAULT = Color.parseColor(&quot;#d32f2f&quot;);</span><br><span class="line">    private final static int OUTER_COLOR_DEFAULT = Color.parseColor(&quot;#f44336&quot;);</span><br><span class="line">    private int OUTER_WIDTH_SIZE;</span><br><span class="line">    private int OUTER_HEIGHT_SIZE;</span><br><span class="line">    private int realWidth;//绘图使用的宽</span><br><span class="line">    private int realHeight;//绘图使用的高</span><br><span class="line">    private float innerCenterX;</span><br><span class="line">    private float innerCenterY;</span><br><span class="line">    private float outRadius;</span><br><span class="line">    private float innerRedius;</span><br><span class="line">    private Paint outerPaint;</span><br><span class="line">    private Paint innerPaint;</span><br><span class="line">    private OnNavAndSpeedListener mCallBack = null;</span><br><span class="line">    public interface OnNavAndSpeedListener&#123;</span><br><span class="line">        public void onNavAndSpeed(float nav,float speed);</span><br><span class="line">    &#125;</span><br><span class="line">    public NavController(Context context) &#123;</span><br><span class="line">        this(context,null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public NavController(Context context, AttributeSet attrs) &#123;</span><br><span class="line">        super(context, attrs);</span><br><span class="line">        TypedArray ta = getResources().obtainAttributes(attrs,R.styleable.NavController);</span><br><span class="line">        innerColor = ta.getColor(R.styleable.NavController_InnerColor,INNER_COLOR_DEFAULT);</span><br><span class="line">        outerColor = ta.getColor(R.styleable.NavController_OuterColor,OUTER_COLOR_DEFAULT);</span><br><span class="line">        ta.recycle();</span><br><span class="line">        OUTER_WIDTH_SIZE = dip2px(context,125.0f);</span><br><span class="line">        OUTER_HEIGHT_SIZE = dip2px(context,125.0f);</span><br><span class="line">        outerPaint = new Paint();</span><br><span class="line">        innerPaint = new Paint();</span><br><span class="line">        outerPaint.setColor(outerColor);</span><br><span class="line">        outerPaint.setStyle(Paint.Style.FILL_AND_STROKE);</span><br><span class="line">        innerPaint.setColor(innerColor);</span><br><span class="line">        innerPaint.setStyle(Paint.Style.FILL_AND_STROKE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">        super.onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">        int width = measureWidth(widthMeasureSpec);</span><br><span class="line">        int height = measureHeight(heightMeasureSpec);</span><br><span class="line">        setMeasuredDimension(width,height);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private int measureWidth(int widthMeasureSpec) &#123;</span><br><span class="line">        int widthMode = MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line">        int widthVal = MeasureSpec.getSize(widthMeasureSpec);</span><br><span class="line">        //处理三种模式</span><br><span class="line">        if(widthMode==MeasureSpec.EXACTLY)&#123;</span><br><span class="line">            return widthVal+getPaddingLeft()+getPaddingRight();</span><br><span class="line">        &#125;else if(widthMode==MeasureSpec.UNSPECIFIED)&#123;</span><br><span class="line">            return OUTER_WIDTH_SIZE;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return Math.min(OUTER_WIDTH_SIZE,widthVal);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private int measureHeight(int heightMeasureSpec) &#123;</span><br><span class="line">        int heightMode = MeasureSpec.getMode(heightMeasureSpec);</span><br><span class="line">        int heightVal = MeasureSpec.getSize(heightMeasureSpec);</span><br><span class="line">        //处理三种模式</span><br><span class="line">        if(heightMode==MeasureSpec.EXACTLY)&#123;</span><br><span class="line">            return heightVal+getPaddingTop()+getPaddingBottom();</span><br><span class="line">        &#125;else if(heightMode==MeasureSpec.UNSPECIFIED)&#123;</span><br><span class="line">            return OUTER_HEIGHT_SIZE;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return Math.min(OUTER_HEIGHT_SIZE,heightVal);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123;</span><br><span class="line">        super.onSizeChanged(w, h, oldw, oldh);</span><br><span class="line">        realWidth = w;</span><br><span class="line">        realHeight = h;</span><br><span class="line">        innerCenterX = realWidth/2;</span><br><span class="line">        innerCenterY = realHeight/2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onDraw(Canvas canvas) &#123;</span><br><span class="line">        super.onDraw(canvas);</span><br><span class="line">        outRadius = Math.min(Math.min(realWidth/2-getPaddingLeft(),realWidth/2-getPaddingRight()),Math.min(realHeight/2-getPaddingTop(),realHeight/2-getPaddingBottom()));</span><br><span class="line">        //画外部圆</span><br><span class="line">        canvas.drawCircle(realWidth/2,realHeight/2,outRadius,outerPaint);</span><br><span class="line">        //内部圆</span><br><span class="line">        innerRedius = outRadius*0.5f;</span><br><span class="line">        canvas.drawCircle(innerCenterX,innerCenterY,innerRedius,innerPaint);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean onTouchEvent(MotionEvent event) &#123;</span><br><span class="line">        if(event.getAction()==MotionEvent.ACTION_DOWN)&#123;</span><br><span class="line">            changeInnerCirclePosition(event);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        if(event.getAction()==MotionEvent.ACTION_MOVE)&#123;</span><br><span class="line">            changeInnerCirclePosition(event);</span><br><span class="line">            Log.i(&quot;TAG&quot;,&quot;MOVED&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">        if(event.getAction()==MotionEvent.ACTION_UP)&#123;</span><br><span class="line">            innerCenterX = realWidth/2;</span><br><span class="line">            innerCenterY = realHeight/2;</span><br><span class="line">            invalidate();</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void changeInnerCirclePosition(MotionEvent e) &#123;</span><br><span class="line">        //圆的方程：（x-realWidth/2）^2 +（y - realHeight/2）^2 &lt;= outRadius^2</span><br><span class="line">        //第一步，确定有效的触摸点集</span><br><span class="line">        float X = e.getX();</span><br><span class="line">        float Y = e.getY();</span><br><span class="line">        if(mCallBack!=null)&#123;</span><br><span class="line">            mCallBack.onNavAndSpeed(X,Y);</span><br><span class="line">        &#125;</span><br><span class="line">        boolean isPointInOutCircle = Math.pow(X-realWidth/2,2) +Math.pow(Y-realHeight/2,2)&lt;=Math.pow(outRadius,2);</span><br><span class="line">        if(isPointInOutCircle)&#123;</span><br><span class="line">            Log.i(&quot;TAG&quot;,&quot;inCircle&quot;);</span><br><span class="line">            //两种情况：小圆半径</span><br><span class="line">            boolean isPointInFree = Math.pow(X-realWidth/2,2) +Math.pow(Y-realHeight/2,2)&lt;=Math.pow(outRadius-innerRedius,2);</span><br><span class="line">            if(isPointInFree)&#123;</span><br><span class="line">                innerCenterX = X;</span><br><span class="line">                innerCenterY = Y;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                //处理限制区域，这部分使用触摸点与中心点与外圆方程交点作为内圆的中心点</span><br><span class="line">                //使用近似三角形来确定这个点</span><br><span class="line">                //求出触摸点，触摸点垂足和中心点构成的直角三角形（pointTri）的直角边长</span><br><span class="line">                float pointTriX = Math.abs(realWidth/2-X);//横边</span><br><span class="line">                float pointTriY = Math.abs(realHeight/2-Y);//竖边</span><br><span class="line">                float pointTriZ = (float) Math.sqrt((Math.pow(pointTriX,2)+Math.pow(pointTriY,2)));</span><br><span class="line">                float TriSin = pointTriY/pointTriZ;</span><br><span class="line">                float TriCos = pointTriX/pointTriZ;</span><br><span class="line">                //求出在圆环上的三角形的两个直角边的长度</span><br><span class="line">                float limitCircleTriY = (outRadius-innerRedius)*TriSin;</span><br><span class="line">                float limitCircleTriX = (outRadius-innerRedius)*TriCos;</span><br><span class="line">                //确定内圆中心点的位置，分四种情况</span><br><span class="line">                if(X&gt;=realWidth/2 &amp;&amp; Y&gt;=realHeight/2)&#123;</span><br><span class="line">                    innerCenterX = realWidth/2+limitCircleTriX;</span><br><span class="line">                    innerCenterY = realHeight/2+limitCircleTriY;</span><br><span class="line">                &#125;else if(X&lt;realWidth/2 &amp;&amp; Y&gt;=realHeight/2)&#123;</span><br><span class="line">                    innerCenterX = realWidth/2-limitCircleTriX;</span><br><span class="line">                    innerCenterY= realHeight/2+limitCircleTriY;</span><br><span class="line">                &#125;else if(X&gt;=realWidth/2 &amp;&amp; Y&lt;realHeight/2)&#123;</span><br><span class="line">                    innerCenterX = realWidth/2+limitCircleTriX;</span><br><span class="line">                    innerCenterY= realHeight/2-limitCircleTriY;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    innerCenterX = realWidth/2-limitCircleTriX;</span><br><span class="line">                    innerCenterY= realHeight/2-limitCircleTriY;</span><br><span class="line">                &#125;</span><br><span class="line">                Log.i(&quot;TAG&quot;,&quot;inLimit&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            invalidate();</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            Log.i(&quot;TAG&quot;,&quot;notInCircle&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void setOnNavAndSpeedListener(OnNavAndSpeedListener listener)&#123;</span><br><span class="line">        mCallBack = listener;</span><br><span class="line">    &#125;</span><br><span class="line">    public static int dip2px(Context context, float dpValue)&#123;</span><br><span class="line">        final float scale = context.getResources().getDisplayMetrics().density;</span><br><span class="line">        return (int) (dpValue*scale +0.5f);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/07/19/Android自定义View系列（二）——打造一个仿2K游戏摇杆/" data-id="cir1zx7bm000bxgyu77glkste" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原创/">原创</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Android自定义View系列（一）——打造一个爱心进度条" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/18/Android自定义View系列（一）——打造一个爱心进度条/" class="article-date">
  <time datetime="2016-07-18T12:23:18.000Z" itemprop="datePublished">2016-07-18</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android-实战/">Android 实战</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/18/Android自定义View系列（一）——打造一个爱心进度条/">Android自定义View系列（一）——打造一个爱心进度条</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>写作原因：Android进阶过程中有一个绕不开的话题——自定义View。这一块是安卓程序员更好地实现功能自主化必须迈出的一步。下面这个系列博主将通过实现几个例子来认识安卓自定义View的方法。从自定义View到自定义ViewGroup，View事件处理再到View深入分析（这一章如果水平未到位可能今后再补充），其中会涉及一些小的知识，包括Canvas的使用、动画等等。系列第一篇文章通过绘制一个心形进度条来学习自定义View的整体流程和简单地贝塞尔曲线的用法。下面开始折磨键盘吧。</strong></p>
<hr>
<h2 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h2><p>先看看今天我们要实现的效果：</p>
<p><img src="http://7xszli.com1.z0.glb.clouddn.com/customview1.PNG" alt="效果"></p>
<p>具体功能就是一个心形的进度条，跟普通的进度条相似，但是显示进度的方式和整体的外观实现了自定义化。这个进度条会根据进度不断加深颜色，效果还不错。通过这个例子读者可以学会基本的自定义View的方法。</p>
<h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><p>我们需要新建一个attrs.xml来描述HeartProgressBar的属性，一个HeartProgressBar.java继承ProgressBar（直接继承View也行），然后通过取出属性，测量，绘制几步来实现自定义View全过程。</p>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><h3 id="一、定义XML属性文件"><a href="#一、定义XML属性文件" class="headerlink" title="一、定义XML属性文件"></a>一、定义XML属性文件</h3><p>新建values/attrs.xml，在XML中声明好各个属性，注意一下format，详细的用法参考官方文档。然后在<declare-styleable>标签下引入属性，具体见下面：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span><br><span class="line">&lt;resources&gt;</span><br><span class="line">    &lt;attr name=&quot;UnReachedColor&quot; format=&quot;color&quot;/&gt;</span><br><span class="line">    &lt;attr name=&quot;ReachedColor&quot; format=&quot;color&quot;/&gt;</span><br><span class="line">    &lt;attr name=&quot;InnerTextColor&quot; format=&quot;color&quot;/&gt;</span><br><span class="line">    &lt;attr name=&quot;InnerTextSize&quot; format=&quot;dimension&quot;/&gt;</span><br><span class="line">    &lt;attr name=&quot;Progress&quot; format=&quot;integer&quot;/&gt;</span><br><span class="line">    &lt;declare-styleable name=&quot;HeartProgressBar&quot;&gt;</span><br><span class="line">        &lt;attr name=&quot;UnReachedColor&quot;/&gt;</span><br><span class="line">        &lt;attr name=&quot;ReachedColor&quot; /&gt;</span><br><span class="line">        &lt;attr name=&quot;InnerTextColor&quot; /&gt;</span><br><span class="line">        &lt;attr name=&quot;InnerTextSize&quot; /&gt;</span><br><span class="line">        &lt;attr name=&quot;Progress&quot;/&gt;</span><br><span class="line">    &lt;/declare-styleable&gt;</span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure></declare-styleable></p>
<h3 id="二、获取XML中的属性"><a href="#二、获取XML中的属性" class="headerlink" title="二、获取XML中的属性"></a>二、获取XML中的属性</h3><p>这一步我们使用obtainAttributes()方法来获取开发者在布局中为我们的View设定的参数值。通过<code>TypedArray ta = getResources().obtainAttributes(attrs,R.styleable.HeartProgressBar);</code>获得TypedArray对象，使用该对象的get系列方法来获取参数值，如：<code>unReachedColor = ta.getColor(R.styleable.HeartProgressBar_UnReachedColor,UNREACHEDCOLOR_DEFAULT);</code>。后面的UNREACHEDCOLOR_DEFAULT是默认参数值，是view创建者定义的，注意尺寸相关的需要进行单位转换。这样就取到了View的参数，这些参数是我们用来定义View的部分元素。</p>
<h3 id="三、调用onMeasure-测量"><a href="#三、调用onMeasure-测量" class="headerlink" title="三、调用onMeasure()测量"></a>三、调用onMeasure()测量</h3><p>这一步常常令许多人头大甚至望而却步，看了很多资料也理解不了。我在这里分享一下对于这一块的理解，希望能够帮助大家理解。首先得明白View的规格是受承载它的View或者ViewGroup影响的。这点很重要，因为这点才出现了三种测量模式：MeasureSpec.EXACTLY、MeasureSpec.UNSPECIFIED和MeasureSpec.AT_MOST。这三种测量模式分别对应三种情况：View有确定的宽高（包括match_parent和具体值两种情况），此时使用EXACTLY，直接把MeasureSpec.getSize()返回就行;View没有确定的宽高（即wrap_content），此时可能系统会使用MeasureSpec.UNSPECIFIED或者MeasureSpec.AT_MOST。在MeasureSpec.UNSPECIFIED中我们把尽量容纳View的尺寸返回给父View去处理，而在MeasureSpec.AT_MOST中则由于父View对子View的限制需要比对父View的限制的最大情况和子View尽可能容纳的尺寸，然后返回相对较小的值。看看本文的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int usedHeight = getRealHeight(heightMeasureSpec);</span><br><span class="line">int usedWidth = getRealWidth(widthMeasureSpec);</span><br><span class="line">setMeasuredDimension(usedWidth,usedHeight);</span><br></pre></td></tr></table></figure></p>
<p>这里将宽高测量后使用setMeasureDimension()返回给父View去处理。<br>以宽为例，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public int getRealWidth(int widthMeasureSpec) &#123;</span><br><span class="line">        int widthMode = MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line">        int widthVal = MeasureSpec.getSize(widthMeasureSpec);</span><br><span class="line">        //取得父View或ViewGroup分配的默认为子View的大小和模式</span><br><span class="line">        paddingLeft = getPaddingLeft();</span><br><span class="line">        paddingRight = getPaddingRight();</span><br><span class="line">        //注意处理一下Padding，把Padding值也赋给想要设置的子View的大小</span><br><span class="line">        if(widthMode == MeasureSpec.EXACTLY)&#123;</span><br><span class="line">            return paddingLeft+paddingRight+widthVal;</span><br><span class="line">            //精确模式下返回具体值</span><br><span class="line">        &#125;else if(widthMode == MeasureSpec.UNSPECIFIED)&#123;</span><br><span class="line">            return (int) (Math.abs(underPaint.ascent()-underPaint.descent()) + paddingLeft + paddingRight);</span><br><span class="line">            //未确定模式下返回尽可能容纳View的尺寸</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return (int) Math.min((Math.abs(underPaint.ascent()-underPaint.descent()) + paddingLeft + paddingRight),widthVal);</span><br><span class="line">            //AT_MOST下返回父View限制值和View尽可能大尺寸之间的最小值</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>使用MeasureSpec.getMode()和getSize()分别取得测量模式和大小，然后处理三种测量模式下的大小值，最后再使用setMeasureDimension()将值返回。对于三种模式下的处理见上面的注释。自定义View中的测量是一块难点，应该详细阅读并实践。</p>
<h3 id="四、重写onSizeChanged-获取最终View的宽高值"><a href="#四、重写onSizeChanged-获取最终View的宽高值" class="headerlink" title="四、重写onSizeChanged()获取最终View的宽高值"></a>四、重写onSizeChanged()获取最终View的宽高值</h3><p>当父View真正为子View分配好空间后会回调这个方法，所以我们应该在里面取得最终的大小值。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">realWidth = w;</span><br><span class="line">realHeight = h;</span><br></pre></td></tr></table></figure></p>
<h3 id="五、重写onDraw-方法绘制图像"><a href="#五、重写onDraw-方法绘制图像" class="headerlink" title="五、重写onDraw()方法绘制图像"></a>五、重写onDraw()方法绘制图像</h3><p>这一步是整个流程中的重点步骤，所有的绘制工作都是在这里进行的。一般绘制的时候都要考虑尺寸问题，我们使用的宽高尺寸是onSizeChanged里面取出的，使用该尺寸来绘制，注意一定要对Padding进行处理（博主写完发现没处理，现在要修改发现很浪费时间就没做处理了。。。读者可以自行处理作为练习）这里有个难点，由于心形的特殊性，我们使用贝塞尔曲线来绘制。关于贝塞尔曲线，在这里就不班门弄斧了，只是说一下这种曲线可以将许多复杂的曲线转化成数学公式来描述，曲线由两种类型的点决定：起末点决定曲线的大概位置，其他点决定曲线的形状和弯曲程度。贝塞尔曲线有一阶二阶三阶高阶之分，具体见下面图片。<br><img src="http://hi.csdn.net/attachment/201008/28/0_1282984413d5g2.gif" alt="一阶"></p>
<p><img src="http://hi.csdn.net/attachment/201008/28/0_1282984428GQ1X.gif" alt="二阶"></p>
<p><img src="http://hi.csdn.net/attachment/201008/28/0_1282984443K2nb.gif" alt="三阶"></p>
<p><img src="http://hi.csdn.net/attachment/201008/28/0_1282984909h1A9.gif" alt="高阶"></p>
<p>安卓中支持二阶和三阶贝塞尔曲线，方法分别为quadTo()和cubicTo()两个。本文使用cubicTo来实现。但是想想心形的形状，如果真的要自己用数学的方法去确定那几个点的位置，呵呵，我是办不到了。那怎么办？博主找到一个方法，在线生成贝塞尔曲线然后用ps标尺工具来确定点与宽高的比例关系……虽然还是很麻烦，但我还没想到别的方法或者工具。（<a href="http://www.j--d.com/bezier" target="_blank" rel="external">Canvas二次贝塞尔曲线操作实例</a>，这是一个为h5服务的贝塞尔曲线生成工具，将就用下……）如果读者有希望能分享一下，谢谢！<br>这是我得到的测量图（就是在这里忘了考虑padding，改起来又很麻烦）：<br><img src="http://7xszli.com1.z0.glb.clouddn.com/customview2.PNG" alt="测量图"></p>
<p>接下来就是利用这张图和Canvas来作图了，主要路径关注路径和颜色深浅表示进度的实现：<br>        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">float pro = ((float)progress)/100.0f;</span><br><span class="line">      int nowColor = (int) argbEvaluator.evaluate(pro,unReachedColor,reachedColor);</span><br><span class="line">      underPaint.setColor(nowColor);</span><br></pre></td></tr></table></figure></p>
<p>上面代码实现了View的颜色随着进度的变化而从某个颜色向另一个颜色变化的功能。ArgbEvaluator类挺实用的，可以实现微信底部滑动颜色变化的功能，这里也是利用它来实现的。</p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">path.moveTo((float) (0.5*realWidth), (float) (0.17*realHeight));</span><br><span class="line">path.cubicTo((float) (0.15*realWidth), (float) (-0.35*realHeight), (float) (-0.4*realWidth), (float) (0.45*realHeight), (float) (0.5*realWidth),realHeight);</span><br><span class="line">path.moveTo((float) (0.5*realWidth),realHeight);</span><br><span class="line">path.cubicTo((float) (realWidth+0.4*realWidth), (float) (0.45*realHeight),(float) (realWidth-0.15*realWidth), (float) (-0.35*realHeight),(float) (0.5*realWidth), (float) (0.17*realHeight));</span><br><span class="line">path.close();</span><br></pre></td></tr></table></figure>
</code></pre><p>上述代码是path路径的绘制，绘制了一个心形的path，如果对于这两个方法有疑问的可以查看API文档。<br>由于我们的进度条跟随进度发生变化，所以我们要重写setProgress()方法，使用invalidate()来刷新onDraw()重绘实现变化。代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    public void setProgress(int progress) &#123;</span><br><span class="line">        this.progress = progress;</span><br><span class="line">        invalidate();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Android自定义View除了上面的测量绘制之外还有对点击事件的处理一大块，这里每个地方都需要花时间去理解和实践才能搞懂，下篇博主会就事件处理和动画一块再次自定义一个View，如果觉得写得好的希望继续关注并喜欢我的简书，也可以关注我的博客。</p>
<h2 id="附录：View具体代码"><a href="#附录：View具体代码" class="headerlink" title="附录：View具体代码"></a>附录：View具体代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">public class HeartProgressBar extends ProgressBar &#123;</span><br><span class="line">   </span><br><span class="line">    private final static int UNREACHEDCOLOR_DEFAULT = 0xFF69B4;</span><br><span class="line">    private final static int REACHEDCOLOR_DEFAULT = 0xFF1493;</span><br><span class="line">    private final static int INNERTEXTCOLOR_DEFAULT = 0xDC143C;</span><br><span class="line">    private final static int INNERTEXTSIZE_DEFAULT = 10;</span><br><span class="line">    private static final int PROGRESS_DEFAULT = 0;</span><br><span class="line">    private int unReachedColor;</span><br><span class="line">    private int reachedColor;</span><br><span class="line">    private int innerTextColor;</span><br><span class="line">    private int innerTextSize;</span><br><span class="line">    private int progress;</span><br><span class="line">    private int realWidth;</span><br><span class="line">    private int realHeight;</span><br><span class="line">    private Paint underPaint;</span><br><span class="line">    private Paint textPaint;</span><br><span class="line">    private Path path;</span><br><span class="line">    private int paddingTop;</span><br><span class="line">    private int paddingBottom;</span><br><span class="line">    private int paddingLeft;</span><br><span class="line">    private int paddingRight;</span><br><span class="line">    private ArgbEvaluator argbEvaluator;</span><br><span class="line">    public HeartProgressBar(Context context) &#123;</span><br><span class="line">        this(context,null);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public HeartProgressBar(Context context, AttributeSet attrs) &#123;</span><br><span class="line">        super(context, attrs);</span><br><span class="line">        argbEvaluator = new ArgbEvaluator();</span><br><span class="line">        TypedArray ta = getResources().obtainAttributes(attrs,R.styleable.HeartProgressBar);</span><br><span class="line">        unReachedColor = ta.getColor(R.styleable.HeartProgressBar_UnReachedColor,UNREACHEDCOLOR_DEFAULT);</span><br><span class="line">        reachedColor = ta.getColor(R.styleable.HeartProgressBar_ReachedColor,REACHEDCOLOR_DEFAULT);</span><br><span class="line">        innerTextColor = ta.getColor(R.styleable.HeartProgressBar_InnerTextColor,INNERTEXTCOLOR_DEFAULT);</span><br><span class="line">        innerTextSize = (int) ta.getDimension(R.styleable.HeartProgressBar_InnerTextSize,INNERTEXTSIZE_DEFAULT);</span><br><span class="line">        progress = ta.getInt(R.styleable.HeartProgressBar_Progress,PROGRESS_DEFAULT);</span><br><span class="line">        ta.recycle();</span><br><span class="line">        Log.i(&quot;nowColor&quot;,progress+&quot;&quot;);</span><br><span class="line">        //声明区</span><br><span class="line">        underPaint = new Paint();</span><br><span class="line">        textPaint = new Paint();</span><br><span class="line">        path = new Path();</span><br><span class="line">        //构造画笔区</span><br><span class="line">        underPaint.setStyle(Paint.Style.FILL_AND_STROKE);</span><br><span class="line">        underPaint.setStrokeWidth(5.0f);</span><br><span class="line">        textPaint.setColor(innerTextColor);</span><br><span class="line">        textPaint.setTextSize(innerTextSize);</span><br><span class="line">        textPaint.setTextAlign(Paint.Align.CENTER);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected synchronized void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123;</span><br><span class="line">        int usedHeight = getRealHeight(heightMeasureSpec);</span><br><span class="line">        int usedWidth = getRealWidth(widthMeasureSpec);</span><br><span class="line">        setMeasuredDimension(usedWidth,usedHeight);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onSizeChanged(int w, int h, int oldw, int oldh) &#123;</span><br><span class="line">        super.onSizeChanged(w, h, oldw, oldh);</span><br><span class="line">        realWidth = w;</span><br><span class="line">        realHeight = h;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected synchronized void onDraw(Canvas canvas) &#123;</span><br><span class="line">        super.onDraw(canvas);</span><br><span class="line">        paddingBottom = getPaddingBottom();</span><br><span class="line">        paddingTop = getPaddingTop();</span><br><span class="line">        paddingLeft = getPaddingLeft();</span><br><span class="line">        paddingRight = getPaddingRight();</span><br><span class="line">        float pro = ((float)progress)/100.0f;</span><br><span class="line">        Log.i(&quot;nowColor&quot;,&quot;pro&quot;+pro+&quot;&quot;);</span><br><span class="line">        int nowColor = (int) argbEvaluator.evaluate(pro,unReachedColor,reachedColor);</span><br><span class="line">        underPaint.setColor(nowColor);</span><br><span class="line">        path.moveTo((float) (0.5*realWidth), (float) (0.17*realHeight));</span><br><span class="line">        path.cubicTo((float) (0.15*realWidth), (float) (-0.35*realHeight), (float) (-0.4*realWidth), (float) (0.45*realHeight), (float) (0.5*realWidth),realHeight);</span><br><span class="line">        path.moveTo((float) (0.5*realWidth),realHeight);</span><br><span class="line">        path.cubicTo((float) (realWidth+0.4*realWidth), (float) (0.45*realHeight),(float) (realWidth-0.15*realWidth), (float) (-0.35*realHeight),(float) (0.5*realWidth), (float) (0.17*realHeight));</span><br><span class="line">        path.close();</span><br><span class="line">        canvas.drawPath(path,underPaint);</span><br><span class="line">        canvas.drawText(String.valueOf(progress),realWidth/2,realHeight/2,textPaint);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public int getRealHeight(int heightMeasureSpec) &#123;</span><br><span class="line">        int heightMode = MeasureSpec.getMode(heightMeasureSpec);</span><br><span class="line">        int heightVal = MeasureSpec.getSize(heightMeasureSpec);</span><br><span class="line">        paddingTop = getPaddingTop();</span><br><span class="line">        paddingBottom = getPaddingBottom();</span><br><span class="line">        if(heightMode == MeasureSpec.EXACTLY)&#123;</span><br><span class="line">            return paddingTop + paddingBottom + heightVal;</span><br><span class="line">        &#125;else if(heightMode == MeasureSpec.UNSPECIFIED)&#123;</span><br><span class="line">            return (int) (Math.abs(underPaint.ascent()-underPaint.descent()) + paddingTop + paddingBottom);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return (int) Math.min((Math.abs(underPaint.ascent()-underPaint.descent()) + paddingTop + paddingBottom),heightVal);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getRealWidth(int widthMeasureSpec) &#123;</span><br><span class="line">        int widthMode = MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line">        int widthVal = MeasureSpec.getSize(widthMeasureSpec);</span><br><span class="line">        paddingLeft = getPaddingLeft();</span><br><span class="line">        paddingRight = getPaddingRight();</span><br><span class="line">        if(widthMode == MeasureSpec.EXACTLY)&#123;</span><br><span class="line">            return paddingLeft+paddingRight+widthVal;</span><br><span class="line">        &#125;else if(widthMode == MeasureSpec.UNSPECIFIED)&#123;</span><br><span class="line">            return (int) (Math.abs(underPaint.ascent()-underPaint.descent()) + paddingLeft + paddingRight);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            return (int) Math.min((Math.abs(underPaint.ascent()-underPaint.descent()) + paddingLeft + paddingRight),widthVal);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void setProgress(int progress) &#123;</span><br><span class="line">        this.progress = progress;</span><br><span class="line">        invalidate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/07/18/Android自定义View系列（一）——打造一个爱心进度条/" data-id="cir1zx7br000dxgyuo120wsnd" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原创/">原创</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Android-IPC机制（三）——利用AIDL实现跨进程通信" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/16/Android-IPC机制（三）——利用AIDL实现跨进程通信/" class="article-date">
  <time datetime="2016-07-16T07:27:16.000Z" itemprop="datePublished">2016-07-16</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android知识库/">Android知识库</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/16/Android-IPC机制（三）——利用AIDL实现跨进程通信/">Android IPC机制（三）——利用AIDL实现跨进程通信</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>写作原因：跨进程通信的实现和理解是Android进阶中重要的一环。下面博主分享IPC一些相关知识、操作及自己在学习IPC过程中的一些理解。这一章是对AIDL的基本使用的介绍，由于博主也是AIDL初学者，所以一些地方阐述可能不准确，如有发现希望指正。关于使用Messenger通信参阅：<a href="http://roadtogeek.cn/2016/07/14/Android-IPC%E6%9C%BA%E5%88%B6%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E5%88%A9%E7%94%A8Messenger%E5%AE%9E%E7%8E%B0%E8%B7%A8%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/" target="_blank" rel="external">Android IPC机制（二）——利用Messenger实现跨进程通信</a>
</strong></p>
<p><a href="https://developer.android.com/guide/components/aidl.html" target="_blank" rel="external">https://developer.android.com/guide/components/aidl.html</a></p>
<hr>
<h2 id="AIDL基本介绍"><a href="#AIDL基本介绍" class="headerlink" title="AIDL基本介绍"></a>AIDL基本介绍</h2><p>关于AIDL，先看看Google官方文档对它的定义：AIDL是接口定义语言，它允许你定义程序接口实现跨进程的客户端与服务端的通信。在Android中，一个进程通常不能访问另一个进程的内存（这是IPC出现的原因），也就是说，进程之间要想通信，就需要将想要共享的对象分解成操作系统能够理解的原始元素通过底层来实现通信。这个过程是乏味无趣的，所以Android帮我们通过AIDL解决了这个问题。（个人翻译）此外，官方文档有说明，只有在不同的客户端与服务端通信，服务端并发处理是才有必要使用这种方式，否则选择Messenger可能更合适。相比Messenger，AIDL有这些优势：<strong>一、跨进程调用服务端的方法；二、服务端并发处理数据时。</strong>上述两种情况使用AIDL更加合适。</p>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>下面开始掌握AIDL的使用方法，先概述一下基本用法：<br>1.服务端创建一个Service监听处理请求，创建一个AIDL文件将暴露给客户端的接口在AIDL文件中声明，然后在Service中实现AIDL接口。<br>2.客户端绑定Service获得Binder对象转化成AIDL接口所属的类型，调用接口中的方法。</p>
<h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>具体实现见下面（下面例子是官方举例的升级版，可以学习一下）：</p>
<p>本例中共有上个文件，MainActivity.java（客户端）、RemoteService.java（服务端）、Command.java（实体类）、IRemoteService.aidl（AIDL文件）、Command.aidl（AIDL文件）。</p>
<h3 id="1-编写AIDL暴露接口"><a href="#1-编写AIDL暴露接口" class="headerlink" title="1.编写AIDL暴露接口"></a>1.编写AIDL暴露接口</h3><p>AIDL文件中只支持六种数据类型：基本数据类型、ArrayList、HashMap、Parcelable和AIDL。本例中我使用基本数据类型和Parcelable来阐述。</p>
<p>由于下面我要使用Parcelable序列化的对象Command，所以先写好Command类：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public class Command implements Parcelable&#123;</span><br><span class="line">    String name;</span><br><span class="line">    int id;</span><br><span class="line">    public static final Parcelable.Creator&lt;Command&gt; CREATOR = new Parcelable.Creator&lt;Command&gt;()&#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public Command createFromParcel(Parcel source) &#123;</span><br><span class="line">            //实现从Parcel容器读取传递数据值，封装成Parcelable对象返回逻辑层</span><br><span class="line">            return new Command(source);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public Command[] newArray(int size) &#123;</span><br><span class="line">            //创建一个类型为T长度为size的数组，仅一句话即可</span><br><span class="line">            return new Command[size];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    private Command()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    private Command(Parcel source)&#123;</span><br><span class="line">        name = source.readString();</span><br><span class="line">        id = source.readInt();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return id+name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public int describeContents() &#123;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void writeToParcel(Parcel dest, int flags) &#123;</span><br><span class="line">        //将对象映射成Parcelable对象，注意与读取的顺序相同</span><br><span class="line">        dest.writeString(name);</span><br><span class="line">        dest.writeInt(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>关于Parcelable序列化，在这里就不多加阐述了，不然这篇文章不知道要多长……序列化的基本方法见上面。官方推荐使用Parcelable是有原因的，Parcelable效率相对高，虽然实现起来比较麻烦。上面类写好之后新建一个Command.aidl文件，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">package com.example.vincebarry.googleaidl;</span><br><span class="line">parcelable Command;</span><br></pre></td></tr></table></figure>
<p>下面实现一下IRemoteService.aidl：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package com.example.vincebarry.googleaidl;</span><br><span class="line">// Declare any non-default types here with import statements</span><br><span class="line">import com.example.vincebarry.googleaidl.Command;</span><br><span class="line">interface IRemoteService &#123;</span><br><span class="line">    int getPid();</span><br><span class="line">    Command getCommand();</span><br><span class="line">    void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat,</span><br><span class="line">            double aDouble, String aString);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里有两个部分要注意:其一是开放的方法接口要准确，其二是把序列化的Command类导入该aidl文件之中。<br>这样，我们就把所需的aidl文件写完了，总结一下：</p>
<ol>
<li><p>首先是一个业务接口aidl文件，该文件包含所有的Service暴露给客户端的方法。此外如果在该文件中使用序列化对象必须将其导入；</p>
</li>
<li><p>序列化对象实现Parcelable接口，实现序列化和反序列化功能，并且将其注册到aidl文件中，注册过程见上面；</p>
</li>
</ol>
<h3 id="2-Service的实现"><a href="#2-Service的实现" class="headerlink" title="2.Service的实现"></a>2.Service的实现</h3><p>这里主要是将接口中的方法实现并且打包到（该词可能不准确）IBinder对象中将其发送到与该Service绑定的客户端去。主要实现了返回当前线程的id和将Service中的Command对象返回的逻辑，具体代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class RemoteService extends Service &#123;</span><br><span class="line">    private Command myCommand;</span><br><span class="line">    @Override</span><br><span class="line">    public IBinder onBind(Intent intent) &#123;</span><br><span class="line">        myCommand = new Command();</span><br><span class="line">        myCommand.setId(10);</span><br><span class="line">        myCommand.setName(&quot;Hello&quot;);</span><br><span class="line">        Toast.makeText(getApplicationContext(),&quot;Remote Service bound&quot;,Toast.LENGTH_SHORT).show();</span><br><span class="line">        return new IRemoteService.Stub()&#123;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public int getPid() throws RemoteException &#123;</span><br><span class="line">                return Process.myPid();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public Command getCommand() throws RemoteException &#123;</span><br><span class="line">                return myCommand;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            @Override</span><br><span class="line">            public void basicTypes(int anInt, long aLong, boolean aBoolean, float aFloat, double aDouble, String aString) throws RemoteException &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-客户端的实现"><a href="#3-客户端的实现" class="headerlink" title="3.客户端的实现"></a>3.客户端的实现</h3><p>客户端方面主要是将Activity与Service绑定，然后将接口存根取出转化为接口，利用该接口来调用服务中的方法。具体代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">ublic class MainActivity extends AppCompatActivity &#123;</span><br><span class="line">    private static final String SERVICE_ACTION = &quot;com.example.vincebarry.googleaidl.RemoteService&quot;;</span><br><span class="line">    private IRemoteService iRemoteService;</span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        Intent intent = new Intent(MainActivity.this,RemoteService.class);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private ServiceConnection conn = new ServiceConnection() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onServiceConnected(ComponentName name, IBinder service) &#123;</span><br><span class="line">            iRemoteService = IRemoteService.Stub.asInterface(service);</span><br><span class="line">            int i = -1;</span><br><span class="line">            String command = null;</span><br><span class="line">            try &#123;</span><br><span class="line">                i = iRemoteService.getPid();</span><br><span class="line">                command = iRemoteService.getCommand().getName()+iRemoteService.getCommand().id;</span><br><span class="line">            &#125; catch (RemoteException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            if(i != -1)&#123;</span><br><span class="line">                Log.i(&quot;Pid&quot;,&quot;Remote Service:&quot;+i);</span><br><span class="line">                Log.i(&quot;Pid&quot;,&quot;Remote Service:&quot;+command);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                Log.i(&quot;Pid&quot;,&quot;Remote Service:&quot;+&quot;null&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onServiceDisconnected(ComponentName name) &#123;</span><br><span class="line">            iRemoteService = null;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>实现下来发现其实理解上难度并不大，只是稍显麻烦，只要前面两章理解好，对于AIDL的通信还是可以较好掌握的，关键还是要多实践。关于多线程并发的情况本文没有讲到，由于博主对于并发编程的掌握局限性的原因就暂时不实现并发情况下的AIDL通信情况，以后对并发理解加深后再作讨论。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/07/16/Android-IPC机制（三）——利用AIDL实现跨进程通信/" data-id="cir1zx7ar0000xgyu1tg3ehud" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原创/">原创</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Android-IPC机制（二）——利用Messenger实现跨进程通信" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/14/Android-IPC机制（二）——利用Messenger实现跨进程通信/" class="article-date">
  <time datetime="2016-07-14T05:10:28.000Z" itemprop="datePublished">2016-07-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android知识库/">Android知识库</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/14/Android-IPC机制（二）——利用Messenger实现跨进程通信/">Android IPC机制（二）——利用Messenger实现跨进程通信</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>写作原因：跨进程通信的实现和理解是Android进阶中重要的一环。下面博主分享IPC一些相关知识、操作及自己在学习IPC过程中的一些理解。这一章使用Messenger实现跨进程通信，其中bindService基础部分参见<a href="http://roadtogeek.cn/2016/07/14/Android-IPC%E6%9C%BA%E5%88%B6%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E7%BB%91%E5%AE%9AService%E5%AE%9E%E7%8E%B0%E6%9C%AC%E5%9C%B0%E9%80%9A%E4%BF%A1/" target="_blank" rel="external">Android IPC机制（一）——绑定Service实现本地通信</a>。</strong></p>
<h2 id="跨进程简介"><a href="#跨进程简介" class="headerlink" title="跨进程简介"></a>跨进程简介</h2><p>在介绍使用Messenger跨进程通信之前先要了解以下问题：为什么需要跨进程通信？只有有了需求才有学习的价值。我个人将不同进程简单的理解为不同的应用程序（当然也有例外，比如可以在同一个应用程序中开启两个或多个进程）。由于进程之间不能像线程一样共享内存，所以数据通信不能像线程一般进行。在Android中可以使用bundle，广播，Messenger，AIDL和Socket进行跨进程通信。本章利用Messenger分别进行单应用程序多进程单向通信和多应用程序多进程双向通信的实现。</p>
<h2 id="Messenger介绍"><a href="#Messenger介绍" class="headerlink" title="Messenger介绍"></a>Messenger介绍</h2><p>Messenger是通过使用Message来实现跨进程通信，一次实现一个请求的方式，这是它的优点也是缺点。其底层实现为AIDL（下章我将阐述）。Messenger的优点是：基于Message，方便使用；支持回调的方式，也就是服务端处理完成长任务可以和客户端交互；不需要编写aidl文件。</p>
<p>Messenger使用流程如下（转载）：<br><img src="http://7xszli.com1.z0.glb.clouddn.com/service3.png" alt="Messenger"></p>
<h2 id="单应用程序多进程单向通信"><a href="#单应用程序多进程单向通信" class="headerlink" title="单应用程序多进程单向通信"></a>单应用程序多进程单向通信</h2><p>先介绍一下Android中单应用程序开启多进程的方法，实际上只要在mainfests中的你想开启新进程的组件的XML中添加<code>&lt;android:progress = &quot;:remote(可以自定义)&quot;&gt;</code>或者<code>&lt;android:progress = &quot;包.remote(可以自定义)&quot;&gt;</code>就行。如：</p>
<p><code>&lt;service android:name=&quot;.CustomService&quot; android:process=&quot;:remote&quot;/&gt;</code></p>
<p>这样就把Service放在新的线程中运行了。</p>
<h3 id="Service实现"><a href="#Service实现" class="headerlink" title="Service实现"></a>Service实现</h3><p>下面是服务端的代码实现，具体思路是：创建一个Handler对象用来处理客户端发送来的消息，再创建一个Messenger对象将上面的Handler对象作为参数传入，这样我们就获得了一个信使。下面就是通过getBinder()把这个信使创建的Binder对象返回给客户端（一旦客户端拿到这个Binder，又可以将它还原为Messenger）。Handler中处理信息为：当得到的Message的what值为MSG_SAY_HELLO时输出Toast。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class CustomService extends Service&#123;</span><br><span class="line">    static final int MSG_SAY_HELLO = 1;</span><br><span class="line">    //实现一个能够处理接收信息的Handler</span><br><span class="line">    class IncomingHandler extends Handler&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void handleMessage(Message msg) &#123;</span><br><span class="line">            super.handleMessage(msg);</span><br><span class="line">            switch(msg.what)&#123;</span><br><span class="line">                case MSG_SAY_HELLO:</span><br><span class="line">                    Toast.makeText(getApplicationContext(),&quot;hello!&quot;,Toast.LENGTH_SHORT).show();</span><br><span class="line">                    break;</span><br><span class="line">                default:</span><br><span class="line">                    super.handleMessage(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //被客户端接收的Messenger对象</span><br><span class="line">    final Messenger messenger = new Messenger(new IncomingHandler());</span><br><span class="line">    @Override</span><br><span class="line">    public IBinder onBind(Intent intent) &#123;</span><br><span class="line">        Toast.makeText(getApplicationContext(),&quot;binding!&quot;,Toast.LENGTH_SHORT).show();</span><br><span class="line">        return messenger.getBinder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Activity实现"><a href="#Activity实现" class="headerlink" title="Activity实现"></a>Activity实现</h3><p>在客户端中我们应该做的是：拿到服务端传来的Messenger对象（在ServiceConnection中取得，具体参见上一篇文章），然后创建一个Message对象，为Message写入数据，注意Message中的what要与服务端中Handler对象中的what一致。使用该Messenger通过send()将Message发送给服务端，这样就可以实现客户端与服务端的单向通信了。具体代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line">    private Button mBtStart;</span><br><span class="line">    private Messenger messenger = null;</span><br><span class="line">    private boolean mBound;</span><br><span class="line">    private TextView mTvMsg;</span><br><span class="line">    private ServiceConnection serviceConnection = new ServiceConnection() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onServiceConnected(ComponentName name, IBinder service) &#123;</span><br><span class="line">            messenger = new Messenger(service);</span><br><span class="line">            mBound = true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onServiceDisconnected(ComponentName name) &#123;</span><br><span class="line">            messenger = null;</span><br><span class="line">            mBound = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    public void sayHello(View v)&#123;</span><br><span class="line">        if(!mBound) return;</span><br><span class="line">        Message msg = Message.obtain(null,CustomService.MSG_SAY_HELLO,0,0);</span><br><span class="line">        try&#123;</span><br><span class="line">            messenger.send(msg);</span><br><span class="line">        &#125;catch (RemoteException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        mBtStart = (Button) findViewById(R.id.bt_start);</span><br><span class="line">        mTvMsg = (TextView) findViewById(R.id.tv_msg);</span><br><span class="line">        mBtStart.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(View v) &#123;</span><br><span class="line">                Intent intent = new Intent(MainActivity.this,CustomService.class);</span><br><span class="line">                bindService(new Intent(MainActivity.this,CustomService.class),serviceConnection, Context.BIND_AUTO_CREATE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    protected void onStop() &#123;</span><br><span class="line">        super.onStop();</span><br><span class="line">        // Unbind from the service</span><br><span class="line">        if (mBound) &#123;</span><br><span class="line">            unbindService(serviceConnection);</span><br><span class="line">            mBound = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上过程一开始理解可能会有些抽象，多动手才能加深理解。</p>
<h2 id="多应用程序多进程双向通信"><a href="#多应用程序多进程双向通信" class="headerlink" title="多应用程序多进程双向通信"></a>多应用程序多进程双向通信</h2><p>仍然以Activity和Service通信为例，不过这次我们需要新建两个Module（ClientApp和ServiceApp），ClientApp中就一个Activity，ServiceApp中一个Service（关于没有Activity的App的启动方式自行百度）。这样就是两个应用程序两个进程的情况了。下面开始分析这种情况下的Messenger的用法：</p>
<h3 id="Service实现-1"><a href="#Service实现-1" class="headerlink" title="Service实现"></a>Service实现</h3><p>依然是先从Service开始。大致思路与上面的Service的创建类似，但又一点不同的是，这次我们需要新建一个clientMessenger来实现Service向客户端发送Message操作。在Service的Handler中有这样一段代码，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">clientMessenger = msg.replyTo;//这个Message是在客户端中创建的</span><br><span class="line">                if(clientMessenger!=null)&#123;</span><br><span class="line">                    Message msgToClient = Message.obtain();</span><br><span class="line">                    msgToClient.what = SEND_MESSAGE_CODE;</span><br><span class="line">                    Bundle bundle = new Bundle();</span><br><span class="line">                    bundle.putString(&quot;msg&quot;,&quot;客户端，我接收到你的消息了，这是我回应给你的，看到了吗？&quot;);</span><br><span class="line">                    msgToClient.setData(bundle);</span><br><span class="line">                    try &#123;</span><br><span class="line">                        clientMessenger.send(msgToClient);</span><br><span class="line">                    &#125; catch (RemoteException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码用来接收到客户端发送来的数据后向客户端发送数据作出回应。注意这里的<code>clientMessenger = msg.replyTo;</code>，是指从客户端中取出与msg一道捆绑过来的clientMessenger对象。利用clientMessenger就可以实现向Activity中返回数据了。</p>
<p>详细代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public class MyService extends Service &#123;</span><br><span class="line">    private static final int RECEIVE_MESSAGE_CODE = 0x0001;</span><br><span class="line">    private static final int SEND_MESSAGE_CODE = 0x0002;</span><br><span class="line"></span><br><span class="line">    private Messenger clientMessenger = null;</span><br><span class="line">    private Messenger serviceMessenger = new Messenger(new ServiceHandler());</span><br><span class="line">    @Override</span><br><span class="line">    public IBinder onBind(Intent intent) &#123;</span><br><span class="line">        return serviceMessenger.getBinder();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate() &#123;</span><br><span class="line">        super.onCreate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onDestroy() &#123;</span><br><span class="line">        super.onDestroy();</span><br><span class="line">        clientMessenger = null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private class ServiceHandler extends Handler&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void handleMessage(Message msg) &#123;</span><br><span class="line">            super.handleMessage(msg);</span><br><span class="line">            if(msg.what == RECEIVE_MESSAGE_CODE)&#123;</span><br><span class="line">                Bundle data = msg.getData();</span><br><span class="line">                if(data != null)&#123;</span><br><span class="line">                    String str = data.getString(&quot;msg&quot;);</span><br><span class="line">                    Toast.makeText(getApplicationContext(),&quot;Service:I received the message:&quot;+str,Toast.LENGTH_SHORT).show();</span><br><span class="line">                &#125;</span><br><span class="line">                clientMessenger = msg.replyTo;//这个Message是在客户端中创建的</span><br><span class="line">                if(clientMessenger!=null)&#123;</span><br><span class="line">                    Message msgToClient = Message.obtain();</span><br><span class="line">                    msgToClient.what = SEND_MESSAGE_CODE;</span><br><span class="line">                    Bundle bundle = new Bundle();</span><br><span class="line">                    bundle.putString(&quot;msg&quot;,&quot;客户端，我接收到你的消息了，这是我回应给你的，看到了吗？&quot;);</span><br><span class="line">                    msgToClient.setData(bundle);</span><br><span class="line">                    try &#123;</span><br><span class="line">                        clientMessenger.send(msgToClient);</span><br><span class="line">                    &#125; catch (RemoteException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Activity实现-1"><a href="#Activity实现-1" class="headerlink" title="Activity实现"></a>Activity实现</h3><p>Activity中主要是实现绑定发送数据和解除绑定两大块功能。绑定先发送显式Intent（5.0以上不支持隐式启动Service，具体操作见下面的启动过程）绑定Service，当绑定成功后获取Messenger对象并使用该对象发送Message对象msg给Service，具体操作与上面的一样。这里有一点不一样的是，为了能够使得Service能获得clientMessenger，我们必须手动将msg与clientMessenger关联，即：<code>msg.replyTo = clientMessenger;</code>。这样Service在获得Activity发送过来的Message的同时也可以取到clientMessenger。而clientMessenger必须先创建出来，方法与单向获取时一致。</p>
<p>详细代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity&#123;</span><br><span class="line">    private Button mBtBind;</span><br><span class="line">    private Button mBtUnBind;</span><br><span class="line">    private TextView mTvMsg;</span><br><span class="line"></span><br><span class="line">    private static final int SEND_MESSAGE_CODE = 0x0001;</span><br><span class="line">    private static final int RECEIVE_MESSAGE_CODE = 0x0002;</span><br><span class="line">    private boolean isBound = false;</span><br><span class="line"></span><br><span class="line">    private String SERVICE_ACTION = &quot;com.example.serviceapp.MyService&quot;;</span><br><span class="line"></span><br><span class="line">    private Messenger serviceMessenger = null;</span><br><span class="line"></span><br><span class="line">    private Messenger clientMessenger = new Messenger(new ClientHandler());</span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        mBtBind = (Button) findViewById(R.id.bt_bind);</span><br><span class="line">        mBtUnBind = (Button) findViewById(R.id.bt_unbind);</span><br><span class="line">        mTvMsg = (TextView) findViewById(R.id.tv_msg);</span><br><span class="line">        mBtUnBind.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(View v) &#123;</span><br><span class="line">                if(isBound)&#123;</span><br><span class="line">                    unbindService(serviceConnection);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        mBtBind.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(View v) &#123;</span><br><span class="line">                if(!isBound)&#123;</span><br><span class="line">                    Intent intent = new Intent();</span><br><span class="line">                    intent.setAction(SERVICE_ACTION);</span><br><span class="line">                    intent.addCategory(Intent.CATEGORY_DEFAULT);</span><br><span class="line">                    PackageManager pm = getPackageManager();</span><br><span class="line">                    ResolveInfo info = pm.resolveService(intent,0);</span><br><span class="line">                    if(info != null)&#123;</span><br><span class="line">                        String packageName = info.serviceInfo.packageName;</span><br><span class="line">                        String serviceName = info.serviceInfo.name;</span><br><span class="line">                        ComponentName componentName = new ComponentName(packageName,serviceName);</span><br><span class="line">                        intent.setComponent(componentName);</span><br><span class="line">                        bindService(intent,serviceConnection,BIND_AUTO_CREATE);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    private ServiceConnection serviceConnection = new ServiceConnection() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onServiceConnected(ComponentName name, IBinder service) &#123;</span><br><span class="line">            serviceMessenger = new Messenger(service);</span><br><span class="line">            isBound = true;</span><br><span class="line">            Message msg = Message.obtain();</span><br><span class="line">            msg.what = SEND_MESSAGE_CODE;</span><br><span class="line">            Bundle data = new Bundle();</span><br><span class="line">            data.putString(&quot;msg&quot;,&quot;你好，MyService，我是客户端&quot;);</span><br><span class="line">            msg.setData(data);</span><br><span class="line">            msg.replyTo = clientMessenger;</span><br><span class="line">            try &#123;</span><br><span class="line">                serviceMessenger.send(msg);</span><br><span class="line">            &#125; catch (RemoteException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onServiceDisconnected(ComponentName name) &#123;</span><br><span class="line">            serviceMessenger = null;</span><br><span class="line">            isBound = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    private class ClientHandler extends Handler&#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void handleMessage(Message msg) &#123;</span><br><span class="line">            super.handleMessage(msg);</span><br><span class="line">            if(msg.what == RECEIVE_MESSAGE_CODE)&#123;</span><br><span class="line">                Bundle data = msg.getData();</span><br><span class="line">                if(data != null)&#123;</span><br><span class="line">                    String str = data.getString(&quot;msg&quot;);</span><br><span class="line">                    mTvMsg.setText(str);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一块理解起来可能比较吃力，所以希望读者多加尝试，为后面的AIDL跨通信方式学习做准备。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/07/14/Android-IPC机制（二）——利用Messenger实现跨进程通信/" data-id="cir1zx7bd0009xgyu0mzyx5gd" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原创/">原创</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Android-IPC机制（一）——绑定Service实现本地通信" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/14/Android-IPC机制（一）——绑定Service实现本地通信/" class="article-date">
  <time datetime="2016-07-14T02:38:15.000Z" itemprop="datePublished">2016-07-14</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android知识库/">Android知识库</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/14/Android-IPC机制（一）——绑定Service实现本地通信/">Android IPC机制（一）——绑定Service实现本地通信</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>写作原因：跨进程通信的实现和理解是Android进阶中重要的一环。下面博主分享IPC一些相关知识、操作及自己在学习IPC过程中的一些理解。<br>这一章是为下面的Messenger和AIDL的使用做准备，主要讲解Android Service的绑定和Activity与本地Service之间通信相关知识。</strong></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>我们都知道启动Service有两种方式：startService()和bindService()。相比第一种方式，bindService()能够更加灵活地实现与启动端Activity的数据通信，第一种启动方式启动Activity与Service之间并没有直接关联，难以直接实现通信（当然了，使用BroadCast或者事件总线也是可以实现的）。而使用绑定的方式启动Service则可以实现Service之间的通信。下面就讲述一下绑定Service实现本地通信的流程。</p>
<p>以Activity调用Service中的方法为例，具体流程参考博主绘制的流程图：</p>
<p><img src="http://7xszli.com1.z0.glb.clouddn.com/service1.png" alt="service01"></p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>结合图片我们来模拟开启一个后台执行更新功能为例来讲解本地Service的绑定。</p>
<p>先分析一下该需求的场景：首先我们需要点击Start按钮开启后台更新数据，后台将数据返回给Activity并在ProgressBar展示进度；当我们点击Pause时后台暂停更新；点击Stop按钮时关闭后台。本例中也用到Service通过BroadCast向Activity传递数据。由于只是实例，对于线程操作一块有一些bug，希望大家能够帮忙指正。</p>
<p>Activity的布局如下：<br><img src="http://7xszli.com1.z0.glb.clouddn.com/service2.PNG" alt="service02"></p>
<h2 id="Service实现"><a href="#Service实现" class="headerlink" title="Service实现"></a>Service实现</h2><p>先看看Service的实现：<br>思路是这样的：先继承Binder类创建MyBinder类，把MyBinder看做Service与Activity通信的代理人，所以在MyBinder内部中写好方法间接调用Service中的方法以供Activity去调用（如本例中callPauseUpgrade()）。关于IBinder对象的获取除了直接重写后面还有两种方式，这里先不阐述了。在Service中我们开启一个Thread，在这个Thread中模拟持续更新进度条直到isStop为False或者progress大于等于100时，然后将进度广播出去，让Activity接收到广播进行进度条更新。Service中供Activity调用的方法实现暂停和停止Thread的功能，具体过程参照代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">public class UpgradeService extends Service &#123;</span><br><span class="line">    private Thread thread;</span><br><span class="line">    private Intent intent;</span><br><span class="line">    private int progress;</span><br><span class="line">    private Boolean isStop;</span><br><span class="line">    public class MyBinder extends Binder&#123;</span><br><span class="line">        public void callPauseUpgrade()&#123;</span><br><span class="line">            pauseUpgrade();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void callStopUpgrade() &#123;</span><br><span class="line">            stopUpgrade();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void stopUpgrade() &#123;</span><br><span class="line">        progress = 0;</span><br><span class="line">        isStop = false;</span><br><span class="line">        intent.putExtra(&quot;progress&quot;,progress);</span><br><span class="line">        sendBroadcast(intent);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate() &#123;</span><br><span class="line">        super.onCreate();</span><br><span class="line">        progress = 0;</span><br><span class="line">        isStop = true;</span><br><span class="line">        intent = new Intent();</span><br><span class="line">        thread = new Thread(new Runnable() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void run() &#123;</span><br><span class="line">                while(isStop)&#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        Thread.sleep(1000);</span><br><span class="line">                    &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                    progress = progress +5;</span><br><span class="line">                    intent.putExtra(&quot;progress&quot;,progress);</span><br><span class="line">                    intent.setAction(&quot;UPGRADE_ACTION&quot;);</span><br><span class="line">                    sendBroadcast(intent);</span><br><span class="line">                    if(progress&gt;=100) break;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void pauseUpgrade() &#123;</span><br><span class="line">        //TODO:Pause the upgrade</span><br><span class="line">        Toast.makeText(getApplicationContext(),&quot;暂停&quot;,Toast.LENGTH_SHORT).show();</span><br><span class="line">        isStop = false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public IBinder onBind(Intent intent) &#123;</span><br><span class="line">        return new MyBinder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Activity实现"><a href="#Activity实现" class="headerlink" title="Activity实现"></a>Activity实现</h2><p>下面是在客户端实现与Service的通信代码。主要思路是：先注册广播实现Service数据的返回；单击Start按钮时实现与Service的绑定，创建ServiceConnection对象实现ServiceConnection接口，分别回调绑定成功和失败两种情况下的逻辑。当成功时获取MyBinder对象，并将设置的isBound值设为true；当失败时将isBound设置为false。单击Pause调用MyBinder对象的callPauseUpgrade()方法间接调用Service中的pauseUpgrade()方法。单击Stop调用callStopUpgrade()方法并且解除绑定。注意解除绑定事件只能执行一次，否则程序会崩溃。具体实现并不难，主要是认真理解上面的流程图即可。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity implements View.OnClickListener&#123;</span><br><span class="line">    private Button mBtStart;</span><br><span class="line">    private Button mBtStop;</span><br><span class="line">    private Button mBtPause;</span><br><span class="line">    private ProgressBar mPbProgress;</span><br><span class="line">    private UpgradeService.MyBinder myBinder;</span><br><span class="line">    private boolean isBound;</span><br><span class="line">    private UpgradeReceiver upgradeReceiver;</span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        IntentFilter intentFilter = new IntentFilter();</span><br><span class="line">        intentFilter.addAction(&quot;UPGRADE_ACTION&quot;);</span><br><span class="line">        upgradeReceiver = new UpgradeReceiver();</span><br><span class="line">        registerReceiver(upgradeReceiver,intentFilter);</span><br><span class="line">        initView();</span><br><span class="line">        initEvent();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    public class UpgradeReceiver extends BroadcastReceiver&#123;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onReceive(Context context, Intent intent) &#123;</span><br><span class="line">            mPbProgress.setProgress(intent.getIntExtra(&quot;progress&quot;,0));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    protected void onDestroy() &#123;</span><br><span class="line">        super.onDestroy();</span><br><span class="line">        unregisterReceiver(upgradeReceiver);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void initEvent() &#123;</span><br><span class="line">        mBtPause.setOnClickListener(this);</span><br><span class="line">        mBtStart.setOnClickListener(this);</span><br><span class="line">        mBtStop.setOnClickListener(this);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private void initView() &#123;</span><br><span class="line">        mBtPause = (Button) findViewById(R.id.bt_pause);</span><br><span class="line">        mBtStart = (Button) findViewById(R.id.bt_start);</span><br><span class="line">        mBtStop = (Button) findViewById(R.id.bt_stop);</span><br><span class="line">        mPbProgress = (ProgressBar) findViewById(R.id.pb_progress);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public void onClick(View v) &#123;</span><br><span class="line">        switch(v.getId())&#123;</span><br><span class="line">            case R.id.bt_pause:</span><br><span class="line">                if(isBound&amp;&amp;myBinder!=null)&#123;</span><br><span class="line">                    myBinder.callPauseUpgrade();</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            case R.id.bt_start:</span><br><span class="line">                bindService(new Intent(MainActivity.this,UpgradeService.class),conn,BIND_AUTO_CREATE);</span><br><span class="line">                break;</span><br><span class="line">            case R.id.bt_stop:</span><br><span class="line">                if(isBound) &#123;</span><br><span class="line">                    myBinder.callStopUpgrade();</span><br><span class="line">                    unbindService(conn);</span><br><span class="line">                    isBound = false;</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private ServiceConnection conn = new ServiceConnection() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void onServiceConnected(ComponentName name, IBinder service) &#123;</span><br><span class="line">            if(service != null)&#123;</span><br><span class="line">                myBinder = (UpgradeService.MyBinder) service;</span><br><span class="line">                isBound = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onServiceDisconnected(ComponentName name) &#123;</span><br><span class="line">            isBound = false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章是为下面的Messenger和AIDL跨进程通信做准备的，实际上个人感觉真正开发时可以使用EventBus或者RxJava取代这种同进程各个组件通信的问题，有兴趣的读者可以自行尝试。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/07/14/Android-IPC机制（一）——绑定Service实现本地通信/" data-id="cir1zx7az0002xgyutrs7mxli" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原创/">原创</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Square全家桶正传——事件总线介绍及EventBus、Otto使用教程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/12/Square全家桶正传——事件总线介绍及EventBus、Otto使用教程/" class="article-date">
  <time datetime="2016-07-12T08:44:49.000Z" itemprop="datePublished">2016-07-12</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Android快速开发/">Android快速开发</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/12/Square全家桶正传——事件总线介绍及EventBus、Otto使用教程/">Square全家桶正传——事件总线介绍及EventBus、Otto使用教程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><strong>写作原因：没有EventBus之前，Android中各组件之间的通信常常基于广播或者接口等等，写法繁杂而且容易使代码混乱。而事件总线的出现及时地解决了这个问题。下面跟着我的思路一起看看EventBus和Otto的使用吧，两者类似自行取其一，不过一起学习有利于更好地理解事件总线的思想。如果对于Square其他框架有兴趣了解可以点击博客的其他文章。</strong></p>
<p><a href="https://github.com/square/otto" target="_blank" rel="external">https://github.com/square/otto</a></p>
<p><a href="https://github.com/greenrobot/EventBus" target="_blank" rel="external">https://github.com/greenrobot/EventBus</a></p>
<hr>
<h2 id="事件总线定义"><a href="#事件总线定义" class="headerlink" title="事件总线定义"></a>事件总线定义</h2><p>事件总线是一个发布 / 订阅的事件总线。包含4个成分：发布者，订阅者，事件，总线。订阅者订阅事件到总线，发送者发布事件。（来自鸿洋大神的博客）官网上面的图片很好地展示了它的原理：<br><img src="https://github.com/greenrobot/EventBus/blob/master/EventBus-Publish-Subscribe.png?raw=true" alt="EventBus"><br>说白了是观察者模式的一种应用，关于观察者模式可以联系RxJava进行理解：<a href="http://roadtogeek.cn/2016/05/25/Square%E5%85%A8%E5%AE%B6%E6%A1%B6%E5%89%8D%E4%BC%A0%E2%80%94%E2%80%94RxJava%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%EF%BC%88%E4%B8%80%EF%BC%89/" target="_blank" rel="external">Square全家桶前传——RxJava函数式编程入门（一）</a>，个人感觉还是直接把步骤放出来，读者可以结合步骤自行操作更容易理解使用。下面开始讲述EventBus和Otto的使用，导入依赖这里就不再讲述了。</p>
<h2 id="EventBus的使用"><a href="#EventBus的使用" class="headerlink" title="EventBus的使用"></a>EventBus的使用</h2><p>下面以实现在SecondActivity向MainActivity发送信息为例讲解EventBus的使用：</p>
<p>1.创建事件类（理解为用于通信的数据），如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Event &#123;</span><br><span class="line">    private String message;</span><br><span class="line">    public Event(String s)&#123;</span><br><span class="line">        message = s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getMessage() &#123;</span><br><span class="line">        return message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>2.在接收信息方（观察者）注册和反注册，代码如下：</p>
<p>注册：<code>EventBus.getDefault().register(this);</code></p>
<p>反注册：<code>EventBus.getDefault().unregister(this);</code></p>
<p>3.在接收信息方重写回调函数，这里有四种函数供选择，注意<code>@Subscribe</code>注解，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">onEventMainThread//代表这个方法会在UI线程执行</span><br><span class="line">onEventPostThread//代表这个方法会在当前发布事件的线程执行</span><br><span class="line">onEventBackgroundThread//这个方法，如果在非UI线程发布的事件，则直接执行，和发布在同一个线程中。如果在UI线程发布的事件，则加入后台任务队列，使用线程池一个接一个调用。</span><br><span class="line">onEventAsync //加入后台任务队列，使用线程池调用，注意没有BackgroundThread中的一个接一个。</span><br></pre></td></tr></table></figure></p>
<p>4.根据需要发送消息，代码如下：<br><code>EventBus.getDefault().post(new Event(“Message”));</code></p>
<p>就是这么简单的操作即可完成各组件之间通信的问题。</p>
<p>下面附上详细的代码：</p>
<p>布局：<br>MainActivity中一个TextView和一个Button，SecondActivity中一个Button</p>
<p>Java：</p>
<p>MainActivity.java:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class MainActivity extends AppCompatActivity &#123;</span><br><span class="line">    private Button mBtJump;</span><br><span class="line">    private TextView mTvMessage;</span><br><span class="line">    @Override</span><br><span class="line">    protected void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        EventBus.getDefault().register(this);</span><br><span class="line">        mBtJump = (Button) findViewById(R.id.bt_jump);</span><br><span class="line">        mTvMessage = (TextView) findViewById(R.id.tv_receiver);</span><br><span class="line">        mBtJump.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(View v) &#123;</span><br><span class="line">                Intent intent = new Intent(MainActivity.this,SecondActivity.class);</span><br><span class="line">                startActivity(intent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Subscribe</span><br><span class="line">    public void onEventMainThread(Event event)&#123;</span><br><span class="line">        mTvMessage.setText(event.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    protected void onDestroy() &#123;</span><br><span class="line">        super.onDestroy();</span><br><span class="line">        EventBus.getDefault().unregister(this);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>SecondActivity.java:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class SecondActivity extends AppCompatActivity &#123;</span><br><span class="line">    private Button mBtSender;</span><br><span class="line">    @Override</span><br><span class="line">    public void onCreate(Bundle savedInstanceState) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_second);</span><br><span class="line">        mBtSender = (Button) findViewById(R.id.bt_send);</span><br><span class="line">        mBtSender.setOnClickListener(new View.OnClickListener() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void onClick(View v) &#123;</span><br><span class="line">                EventBus.getDefault().post(new Event(&quot;Hello EventBus!&quot;));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void onDestroy() &#123;</span><br><span class="line">        super.onDestroy();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Otto的使用"><a href="#Otto的使用" class="headerlink" title="Otto的使用"></a>Otto的使用</h2><p>除了EventBus以外，Otto也是实现事件总线的优秀的框架，是Square的亲儿子（由于我先看了EventBus，所以亲儿子就只能放在后面了）其用法与EventBus类似，下面给出Otto的用法：</p>
<p>1.定义一个AppBus类继承Bus类，采用单例模式方便以后调用：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class AppBus extends Bus &#123;  </span><br><span class="line"></span><br><span class="line">    private static AppBus bus;  </span><br><span class="line"></span><br><span class="line">    public static AppBus getInstance() &#123;  </span><br><span class="line">        if (bus == null) &#123;  </span><br><span class="line">            bus = new AppBus();  </span><br><span class="line">        &#125;  </span><br><span class="line">        return bus;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>2.创建事件类（与EventBus一样），如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Event &#123;</span><br><span class="line">    private String message;</span><br><span class="line">    public Event(String s)&#123;</span><br><span class="line">        message = s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getMessage() &#123;</span><br><span class="line">        return message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.在接收信息方（观察者）注册和反注册，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">AppBus.getInstance().register(this);  </span><br><span class="line">AppBus.getInstance().unregister(this);</span><br></pre></td></tr></table></figure></p>
<p>4.在接收信息方重写回调函数，注意@Subscribe注解，代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void customName(Event event) &#123;  </span><br><span class="line">        textView.setText(event.getMessage());  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>5.根据需要发送消息，代码如下：<br> AppBus.getInstance().post(new Event(“message”));</p>
<p><strong>补充：Otto可以使用@Produce注解实现事件的产生</strong>，下面的例子正是使用@Produce注解事件产生方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BusProvider.getInstance().post(produceEvent());</span><br><span class="line">@Produce</span><br><span class="line">    public MessageEvent produceEvent() &#123;</span><br><span class="line">        return new MessageEvent(&quot;message&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="Otto与EventBus的对比"><a href="#Otto与EventBus的对比" class="headerlink" title="Otto与EventBus的对比"></a>Otto与EventBus的对比</h2><p>（来自非著名程序员）<br>从事件订阅的处理差别来看：</p>
<ol>
<li>eventbus是采用反射的方式对整个注册的类的所有方法进行扫描来完成注册；</li>
<li>otto采用了注解的方式完成注册；</li>
<li>共同的地方缓存所有注册并有可用性的检测。同时可以移除注册;</li>
<li>注册的共同点都是采用method方法进行一个集成。</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>EventBus和Otto用起来差不多，至于选择哪一个看个人感觉吧，不过既然是Square全家桶，那么使用Otto在兼容性上更有优势。如果会用Rx的话，建议尝试使用Rx来实现通信。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/07/12/Square全家桶正传——事件总线介绍及EventBus、Otto使用教程/" data-id="cir1zx7do0029xgyuflqt3bqe" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原创/">原创</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-Linux菜鸟旅程足迹——Shell基础" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/07/11/Linux菜鸟旅程足迹——Shell基础/" class="article-date">
  <time datetime="2016-07-11T05:25:26.000Z" itemprop="datePublished">2016-07-11</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/Linux学习/">Linux学习</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2016/07/11/Linux菜鸟旅程足迹——Shell基础/">Linux菜鸟旅程足迹——Shell基础</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="Shell的定义"><a href="#Shell的定义" class="headerlink" title="Shell的定义"></a>Shell的定义</h3><p>Shell就是命令解释器，是用户使用操作系统的接口，是命令语言、命令解释器和程序设计语言的统称。Linux使用bash作为默认的Shell，除此以外Linux还有其他的Shell如C Shell等。Shell独立于Linux的内核。</p>
<h3 id="执行命令的顺序"><a href="#执行命令的顺序" class="headerlink" title="执行命令的顺序"></a>执行命令的顺序</h3><p>①别名；②关键字；③函数；④内部命令；⑤外部命令或外部脚本</p>
<h3 id="控制台和终端"><a href="#控制台和终端" class="headerlink" title="控制台和终端"></a>控制台和终端</h3><p>控制台是直接和计算机相连接的原生设备，终端是软件的概念。在RHEL中有6个虚拟控制台和一个真实控制台。</p>
<p>Shell命令行的格式：command [flags] [arguments1] [arguments2]<br>…</p>
<p><strong>注解：具体的只需根据详细的命令进行比对即可知道每个地方的具体意义。help命令在这里就不阐述了，可以直接查阅相关命令手册。</strong></p>
<h3 id="命令和文件名的自动补齐功能"><a href="#命令和文件名的自动补齐功能" class="headerlink" title="命令和文件名的自动补齐功能"></a>命令和文件名的自动补齐功能</h3><p>使用tab键即可直接不全命令和文件名和目录名。</p>
<h3 id="历史命令"><a href="#历史命令" class="headerlink" title="历史命令"></a>历史命令</h3><ol>
<li>history</li>
<li>UP和DOWN键分别可以查阅历史命令</li>
</ol>
<h3 id="命令别名"><a href="#命令别名" class="headerlink" title="命令别名"></a>命令别名</h3><p>alias 别名=‘待替换的终端命令’</p>
<p>直接执行alias会列出目前所有的别名设置</p>
<h3 id="通配符和文件名变量"><a href="#通配符和文件名变量" class="headerlink" title="通配符和文件名变量"></a>通配符和文件名变量</h3><p><code>*</code> 匹配任何字符和任何数目的字符组合</p>
<p><code>？</code> 匹配任何单个字符</p>
<p><code>[]</code> 匹配任何包含在括号中的单字符</p>
<h3 id="输入、输出重定向"><a href="#输入、输出重定向" class="headerlink" title="输入、输出重定向"></a>输入、输出重定向</h3><p>输入、输出重定向是指将系统默认的输入、输出设备（分别为键盘和终端屏幕）重新定义到其它来源或去向（文件）。最基本的用法是将它们重新定向到一个文件，从一个文件获取输入，输出到另一个文件中。</p>
<p>作用：解决多次输入信息和处理输出信息的问题。</p>
<p>&lt;输入重定向<br>如：<br><code>#wc &lt; file //返回文件包含的行数、单词数和字符数</code></p>
<p><code>&gt;</code>输出重定向</p>
<p><code>&gt;&gt;</code>追加重定向</p>
<p><code>2&gt;</code>错误输出重定向</p>
<p>如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#cat &gt;file</span><br><span class="line">hello</span><br><span class="line">//将hello输出到file文件中</span><br><span class="line">#cat &gt;&gt;file</span><br><span class="line">helloworld</span><br><span class="line">//将helloworld追加到file文件中</span><br><span class="line">#ls file 2&gt;error.txt</span><br><span class="line">//如果file不存在那么错误信息将会保存到error.txt中</span><br><span class="line">#cat error.txt</span><br><span class="line">//上面的错误信息可以通过这行命令实现将错误信息输出到终端屏幕上</span><br></pre></td></tr></table></figure></p>
<p>双重输出重定向</p>
<p>1.将正确和错误输出结果分别输出到不同地方：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#ls -l 2&gt;error.txt &gt;result.txt</span><br><span class="line">#ls -l 2&gt;&gt;error.txt &gt;&gt;result.txt</span><br></pre></td></tr></table></figure></p>
<p>2.将错误和正确输出结果输出到同一个地方：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#ls -l &amp;&gt;result.txt</span><br><span class="line">#ls -l &amp;&gt;&gt;result.txt</span><br></pre></td></tr></table></figure></p>
<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>将一个程序或命令的输出作为另一个程序或命令的输入<br>如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ztg.txt | grep &quot;ztg&quot; |wc -l</span><br></pre></td></tr></table></figure></p>
<p>将cat命令的输出作为grep命令的输入，grep命令的输出作为wc的输入</p>
<h3 id="tee"><a href="#tee" class="headerlink" title="tee"></a>tee</h3><p>功能：将标准输入设备（着重）读取数据将其内容输出到标准输出设备和保存成文件。</p>
<p><strong>注解：重定向在Windows批处理命令中也可以使用</strong></p>
<p>欢迎阅读下一篇笔记——Vim、Emacs的使用</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2016/07/11/Linux菜鸟旅程足迹——Shell基础/" data-id="cir1zx7c6000rxgyuemoc0rpg" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/原创/">原创</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/">__('next') &raquo;</a>
  </nav>
</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">分类</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android-Google官方文档/">Android Google官方文档</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android-Studio/">Android Studio</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android-实战/">Android 实战</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android快速开发/">Android快速开发</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android知识库/">Android知识库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Android第三方开源库/">Android第三方开源库</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java基础知识/">Java基础知识</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux学习/">Linux学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/Python基础知识/">Python基础知识</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/心情随笔/">心情随笔</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Java/">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/原创/">原创</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/心情/">心情</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/翻译/">翻译</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/转载/">转载</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/Android/" style="font-size: 17.5px;">Android</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/Linux/" style="font-size: 15px;">Linux</a> <a href="/tags/Python/" style="font-size: 10px;">Python</a> <a href="/tags/原创/" style="font-size: 20px;">原创</a> <a href="/tags/心情/" style="font-size: 10px;">心情</a> <a href="/tags/翻译/" style="font-size: 12.5px;">翻译</a> <a href="/tags/转载/" style="font-size: 15px;">转载</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/07/">七月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/06/">六月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/05/">五月 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/04/">四月 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/07/25/小话java多线程机制/">小话java多线程机制</a>
          </li>
        
          <li>
            <a href="/2016/07/23/小话java注解机制/">小话java注解机制</a>
          </li>
        
          <li>
            <a href="/2016/07/23/小话java反射机制/">小话java反射机制</a>
          </li>
        
          <li>
            <a href="/2016/07/19/Android自定义View系列（二）——打造一个仿2K游戏摇杆/">Android自定义View系列（二）——打造一个仿2K游戏摇杆</a>
          </li>
        
          <li>
            <a href="/2016/07/18/Android自定义View系列（一）——打造一个爱心进度条/">Android自定义View系列（一）——打造一个爱心进度条</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 陈颍聪<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>